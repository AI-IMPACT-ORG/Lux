# Interacting Positive Logic via Connected Semirings (Braided)
## Clean Specification (phase-only default; local-invariance; institution; partial locals; codegen-ready)

> A self-contained definition of a logic and an (implicit) institution, paired with pragmatic implementation notes. The default equality quotients **phase only**; **scale** is opt-in via a mask. Local checkers are **sound but intentionally partial**.

---

### 0. Design goals
- **Invariance under change of local presentation** (driving principle).
- Minimal algebra: bulk = commutative semiring; boundaries = commutative idempotent semirings.
- **Phase-first** design: default equality modulo phase; scale optional.
- Implementation-ready: header factoring of central scalars and a braid dispatcher.
- Institution-ready: signatures carry parameters; satisfaction condition holds.

---

## 1. Signature & Parameters

### 1.1 Sorts and notational conventions
- Sorts/objects: `L` (left), `B` (bulk), `R` (right), unit `I`.
- SMC tensor on objects/morphisms is written `⊗` and **never** overloaded.
- Bulk internal operations are `⊕B`, `⊗B`. Composition `f ; g` = first `f`, then `g`.

### 1.2 Primitive symbols
**Boundary semirings** (`*∈{L,R}`):  
`⊕_* , ⊗_* : *×*→*`, `0_* , 1_* : I→*` (commutative, idempotent).

**Bulk semiring:**  
`⊕B , ⊗B : B×B→B`, `0_B , 1_B : I→B` (commutative, distributive).

**Couplers / observers:**  
`ι_L:L→B`, `ι_R:R→B`, `ν_L:B→L`, `ν_R:B→R`.

**Braiding / curvature:**  
`ad_i:B→B` for `i∈{0,1,2,3}`, central scalars `F_{ij}:I→B` for `i≠j`.

**Central scalars (gauges):**  
`φ, \bar φ : I→B` with `φ ⊗B \bar φ ≡ 1_B` (**phase**),  
`z, \bar z : I→B` with `Λ := z ⊗B \bar z` (**scale**).

**Arity-4 generator + basepoint:**  
`a_0..a_3:I→B`, tuple `\bar a=(a_0,…,a_3)`, operator `Gen4:B^4→B`.

**Flow parameters and observable registry:**  
`μ, θ : I→L` (scale- and phase-flow parameters, constants in L), `Obs : I→B` (observable registry), `J : I→L` (formal sources), `ε_μ, ε_θ : I→L` (discrete step sizes for finite differences).

### 1.3 Parameters (part of the signature/theory)
- **Quotient mask `qmask ⊆ {phase, scale}`** (default `{phase}`).
- **R-data:** assignments/constraints for `{F_{ij}}` (e.g., identity).  
Signature morphisms must **preserve** `qmask`, the phase/scale laws, and the chosen R-data.

---

## 2. Syntax, typing, contexts
- Bulk terms: built from `0_B,1_B`, scalars, `⊕B,⊗B`, `ad_i`, `Gen4`.
- Boundary terms: built from `0_*,1_*`, `⊕_*,⊗_*`.
- Mixing: `ι_*:*→B`, `ν_*:B→*`.  
Contexts (single-hole): `C_B:B→B`; `C_L = ν_L ; C_B` closed under `⊕_L,⊗_L`; similarly for `C_R`.  
All equalities below are **congruences** under these contexts.

---

## 3. Axioms (equational)

### 3.1 Boundary semirings (each `*`)
Commutativity, idempotency, units; distributivity; **absorption** `x ⊗_* (x ⊕_* y) ≡ x`; **annihilation** `0_* ⊗_* x ≡ 0_*`.

### 3.2 Bulk semiring
Commutativity, units, **annihilation** `0_B ⊗B x ≡ 0_B`, distributivity.

### 3.3 Couplers / observers
- Retraction: `ν_* ; ι_* ≡ id_*`.
- Bulk idempotency: `ι_* ; ν_* ; ι_* ≡ ι_*`.
- **Linearity & units:** `ι_*(x ⊕_* y) ≡ ι_*(x) ⊕B ι_*(y)`, `ι_*(x ⊗_* y) ≡ ι_*(x) ⊗B ι_*(y)`, `ι_*(0_*) ≡ 0_B`, `ι_*(1_*) ≡ 1_B`.
- **Observer invariance:** for all integers `n`, `ν_*(x ⊗B φ^n) ≡ ν_*(x)`; and **if `scale∈qmask`**, for all `n≥0`, `ν_*(x ⊗B Λ^n) ≡ ν_*(x)`.

### 3.4 Braided duals (typed pointwise)
For all `t:B` and `i≠j`:  
`ad_i(ad_j(t)) ≡ (ad_j(ad_i(t))) ⊗B F_{ij}`, with `F_{ij} ⊗B F_{ji} ≡ 1_B`, `F_{ii} ≡ 1_B`, and triangle `F_{ij} ⊗B F_{jk} ⊗B F_{ki} ≡ 1_B`.

### 3.5 Basepoint normalization
`Gen4(\bar a) ≡ 0_B`.

### 3.6 Parametric normalizer and cumulant definitions
**Parametric normalizer (mathematically precise):**  
Let `NF(t) = (kφ, mΛ, core)` be the standard normal form. Define `NF_{μ,θ}(t) = (kφ', mΛ', core')` where:
- `kφ' = f_θ(kφ)` for some function `f_θ : ℤ → ℤ` (phase weighting)
- `mΛ' = g_μ(mΛ)` for some function `g_μ : ℕ → ℕ` (scale weighting)  
- `core' = core` (unchanged)
The functions `f_θ, g_μ` are determined by the flow parameters `(μ,θ)`.

**Expectations and cumulants (all definitions, L-valued):**
- `⟨ T ⟩_{μ,θ} := ν_L( NF_{μ,θ}(T) )`                    // expectation via observer
- `g(i; μ,θ) := ⟨ Obs(i) ⟩_{μ,θ}`                        // effective coupling  
- `G(i,j; μ,θ) := ⟨ Obs(i) ⊗B Obs(j) ⟩_{μ,θ} ⊖_L ( g(i; μ,θ) ⊗_L g(j; μ,θ) )`  // connected 2-point

**Beta fields and a/c functions (finite differences in L):**
- `β_μ(i; μ,θ) := ( g(i; μ⊕_L ε_μ, θ) ⊖_L g(i; μ, θ) ) ⊘_L ε_μ`
- `β_θ(i; μ,θ) := ( g(i; μ, θ⊕_L ε_θ) ⊖_L g(i; μ, θ) ) ⊘_L ε_θ`
- `a(μ,θ) := ½ ⊗_L Σ_{i,j∈I_fin} β_μ(i; μ,θ) ⊗_L G(i,j; μ,θ) ⊗_L β_μ(j; μ,θ)`
- `c(μ,θ) := ½ ⊗_L Σ_{i,j∈I_fin} β_θ(i; μ,θ) ⊗_L G(i,j; μ,θ) ⊗_L β_θ(j; μ,θ)`

Note: `⊘_L` denotes division in the L semiring (when `ε_μ, ε_θ` are invertible); `I_fin ⊆ I` is a finite index set. If division is not available, we work in a localization or use alternative formulations.

Closure: smallest congruence generated by the axioms and closed under §2 contexts.

---

## 4. Gauges & active congruence
- **Phase:** `≡_phase` generated by `t ~ t ⊗B φ` with `φ ⊗B \bar φ = 1_B`.
- **Scale:** `≡_scale` generated by `t ~ t ⊗B Λ`.
- **Active congruence:** `≡_qmask :=` closure of the union of those listed by `qmask`.  
**Default:** all bulk comparisons are **modulo phase only**.

---

## 5. Observational equalities (institutional)
Let `≡_*` abbreviate “equality modulo `≡_qmask`.”

- **Left:** `t ≡_L u :⇔ ∀C_L, C_L[t] = C_L[u]` in the L-carrier (ordinary equality).  
- **Bulk:** `t ≡_B u :⇔ ∀C_B, C_B[t] ≡_* C_B[u]`.  
- **Right:** symmetric.  
- **Local-agreement:** `≡_loc := ≡_L ∧ ≡_R`.  
- **Metalogical:** `≡_meta` via any `C:B→B` from the full signature.

### Principle 0 — Local Presentation Invariance
If `t ≡_⋆ (u ⊗B s)` with `s∈⟨φ⟩` (and if `scale∈qmask`, also permit `s∈⟨Λ⟩`), then `t ≡_loc u`.  
*Reason:* `≡_⋆ ⊆ (≡_loc ∩ ≡_meta)`; observers erase phase (and scale when active); congruence closure.

### Reversible helper equality `≡_⋆`
Reversible steps comprise only isomorphisms that are available **in the current theory presentation**:
- Standard SMC isomorphisms (associativity/unit/symmetry) **when** the ambient monoidal structure is explicit in the chosen presentation;
- Braided swaps `ad_i∘ad_j ↔ ad_j∘ad_i ⊗B F_{ij}` (with the corresponding inverse) as permitted by the R‑data;
- Insertion/elimination of `1_B` and paired `φ·\bar φ`.

**Λ invertibility:** We do **not** assume `Λ` has an inverse. A step of the form `Λ·Λ^{-1}` is permitted **only if** an explicit inverse element for `Λ` exists in the scalar fragment of the current theory/model. Observer invariance for scale uses powers `n≥0` for the same reason.

**Parametric normalizer compatibility:** The helper equality `≡_⋆` extends to the parametric normalizer via:
- `(t ≡_⋆ u) ⇒ ( NF_{μ,θ}(t) ≡_⋆ NF_{μ,θ}(u) )`
- `(t ≡_⋆ u) ⇒ ( ⟨t⟩_{μ,θ} =_L ⟨u⟩_{μ,θ} )`

SMC isos are **not required** for core equational reasoning or for the normal form procedure; they only apply in presentations that expose the ambient monoidal structure. In all cases, `≡_⋆ ⊆ (≡_loc ∩ ≡_meta)` remains valid.

---

## 6. Models (soundness witness; non-binding)
Example: log/tropical model `B=(ℝ∪{−∞}, ⊕=max, ⊗=+, 0=−∞, 1=0)`. Let `L=R` be idempotent commutative semirings; `ad_i=id`, `F_{ij}=0`, `φ=0`, `Λ=0`; pick `\bar a` with `Gen4(\bar a)=−∞`. All axioms hold ⇒ consistency.

---

## 7. Algorithmic notes (for implementers)
**Clarity note — factoring vs. equality.** We always factor both `φ` and `Λ` into the header, i.e. every bulk term normalizes to `(kφ:ℤ, mΛ:ℕ, core)`.
Equality, however, **ignores `mΛ`** unless `scale∈qmask`. When `scale∈qmask`, comparisons are made modulo both phase and scale; when it is not, scale contributes via the `core` comparison.

**Parametric normalizer implementation (mathematically precise):**  
`NF_{μ,θ}` applies functions `f_θ : ℤ → ℤ` and `g_μ : ℕ → ℕ` to the header components of the standard normal form. The core reduction and braiding remain identical; only the header transformation is parameterized.

**Standard NF pipeline:**
- `ac-canon` ⇒ `braid-reduce` (dispatcher) ⇒ `strip-phase/scale` ⇒ `basepoint-cut` ⇒ core hash-cons.
- `normal-form` returns `(values kφ mΛ core)`.

**Parametric NF pipeline:**
- Same as standard NF, but header components are transformed: `(kφ, mΛ, core) ↦ (f_θ(kφ), g_μ(mΛ), core)`.
- `normal-form-parametric` returns `(values f_θ(kφ) g_μ(mΛ) core)`.

- **Header factoring:** normalize any bulk term to `(kφ:ℤ, mΛ:ℕ, core)` with `core` free of phase/scale under current `qmask`.
- **Braid dispatcher:** precompute `swap[i][j]` from R-data; reduce `ad`-chains in one left→right pass; accumulate `F_{ij}` in the header/core via `⊗B`.
- **AC canonicalization:** sorted small vectors (RLE) for `⊕B/⊗B`. Eager neutral/zero rules. Basepoint cut. Target `~O(n log n)`; ad-depth near-linear.
- **Cumulant computation:** All cumulant functions (`g`, `G`, `β_μ`, `β_θ`, `a`, `c`) are implemented as thin macros expanding into the definitional formulas using existing `ν_L`, `NF_{μ,θ}`, and L-arithmetic.

---

## 8. Institution appendix (implicit but complete)
- **Signatures `Sig`:** sorts/ops/consts plus parameters (`qmask`, R‑data). Morphisms preserve them.  
- **Sentences `Sen(Σ)`:** finite equational sets over L/B/R.  
- **Models `Mod(Σ)`:** Σ‑algebras satisfying §3 (including observer invariance and coupler properties).  
- **Reduct `Mod(σ)`:** standard forgetful/relabeling, carrying parameters along.  
- **Satisfaction `⊨_Σ`:** B-equations hold modulo `≡_qmask`; L/R equations hold in carriers; observer invariance ensures compatibility.  
- **Satisfaction condition:** For `σ:Σ→Σ'`, `M' ⊨_{Σ'} Sen(σ)(φ)` iff `Mod(σ)(M') ⊨_Σ φ`.

---

## 9. Codegen notes (Agda / Coq / Metamath)
Emit: (i) semiring records for L/R/B; (ii) couplers/observers as homomorphisms with stated laws; (iii) a **setoid** for bulk equality modulo `qmask`; (iv) lemma stub for Principle 0; (v) parametric normalizer and cumulant definitions as derived functions. Backends import the same signature/axioms and map equations accordingly.

---

## 10. "Partial locals" (engineering stance)
Default procedures for `≡_L`/`≡_R` may be **incomplete** (sound 3‑probe basis: `ν_*`, additivity probe, multiplicativity probe), returning `#t/#f/'unknown`. A heavier fallback (e‑graph) can be enabled when completeness is required. This does **not** affect the institutional definitions above.

## 11. Consistency summary
- **Single semantics:** All definitions use the same underlying machinery (`NF`, `ν_L`, L-arithmetic, helper equality `≡_⋆`).
- **DRY principle:** Parametric normalizer wraps existing NF; cumulant functions are thin macros; no duplicate definitions.
- **Institutional soundness:** Parametric normalizer preserves satisfaction condition and morphism properties.
- **Implementation coherence:** Standard and parametric NF pipelines clearly separated; cumulant computation unified.

## 12. Mathematical consistency verification
- **Type consistency:** All operations respect their declared types (`I→L`, `I→B`, `L×L→L`, etc.).
- **Semiring structure:** L-operations (`⊕_L`, `⊗_L`, `⊖_L`, `⊘_L`) respect semiring axioms where applicable.
- **Function composition:** All compositions (`ν_L ∘ NF_{μ,θ}`, etc.) are well-defined.
- **Finite sums:** Summations over `I_fin ⊆ I` are finite and well-defined.
- **Division safety:** `⊘_L` operations are only used when invertibility is guaranteed or alternatives are specified.

*End of clean specification.*
