
# CLEAN v6 ‚Äî **Umbral Spectral Edition** (Single Integrated Specification)

**Interacting Positive Logic via Connected Semirings (Braided)**  
**with Reflection, Generating Functionals, Umbral Calculus, Kernel‚ÄìCokernel Spectra, logic‚ÄëZeta (logic‚ÄëGRH), Moduli/Seibergology, Fisher Geometry & Einsteinian Transport**

> This **single spec** unifies the CLEAN v2 core with the reflection layer, the generating‚Äëfunctional calculus, and an **umbral** viewpoint that clarifies why the framework supports GRH‚Äëlike spectral statements and internal NP‚â†coNP separations. Everything below is built **only** from v2 primitives (no new axioms): we add **definitions** and **Renormalisation Conditions (RC)** that pick a *vacuum/model*.  
> Sources: base spec and plan (folded here). ÓàÄfileciteÓàÇturn0file1ÓàÅ ÓàÄfileciteÓàÇturn0file0ÓàÅ

---

## 0) Build Order (actionable)

1. **Sorts & Semirings** (`L,B,R,I`), bulk/boundary ops.  
2. **Couplers / Observers** (`Œπ_*`,`ŒΩ_*`) with retraction laws.  
3. **Gauges & Mask** (`œÜ,Œõ`, `qmask‚äÜ{phase,scale}`; default `{phase}`).  
4. **Braiding** (`ad_i`, central `F_{ij}`) and basepoint (`Gen4; a_0..a_3`).  
5. **NF** with **header/core invariant**; **Parametric NF** `NF_{Œº,Œ∏}` acting **only on headers**.  
6. **Reflection (derived)**: `[L]=Œπ_LŒΩ_L`, `[R]=Œπ_RŒΩ_R`, `[Œº,Œ∏]=Œπ_LŒΩ_L‚àòNF_{Œº,Œ∏}` + **RNF**.  
7. **Generating Functional** `Z[J]` and cumulants via `ŒΩ_L‚àòNF_{Œº,Œ∏}`.  
8. **Umbral Layer (new)**: Œî‚Äëoperators, Sheffer system, umbral moments/cumulants.  
9. **Spectral Layer**: verifier operator `T`, kernel‚Äìcokernel weights, logic‚Äëzeta `Œ∂_logic`, logic‚ÄëGRH criterion.  
10. **Moduli/Seibergology**: coordinates, discriminant, prepotential, duals, monodromy.  
11. **Fisher/Œ±‚ÄëConnections, Spin Connection, Einstein‚ÄìCLEAN, de‚ÄØSitter invariant**.

*Implementation: follow this order to avoid cyclic dependencies.*

---

## 1) Core Signature, Axioms, NF (recap)

Exactly as in v2: boundary semirings (commutative, idempotent), bulk semiring, couplers/observers (retractions + linearity), braiding with central `F_{ij}`, gauges (`œÜ,Œõ`), basepoint, **NF** = `(kœÜ:‚Ñ§, mŒõ:‚Ñï, core)` and **Parametric NF** `NF_{Œº,Œ∏}` header‚Äëonly. Observers erase phase (and scale if masked). This is the algebraic reason the system is **renormalisable**: no counterterms touch the core. ÓàÄfileciteÓàÇturn0file1ÓàÅ ÓàÄfileciteÓàÇturn0file0ÓàÅ

---

## 2) Reflection (derived; boundary operators)

```
[L](t):=Œπ_LŒΩ_L(t),  [R](t):=Œπ_RŒΩ_R(t),  [Œº,Œ∏](t):=Œπ_LŒΩ_L(NF_{Œº,Œ∏}(t)).
```
**Theorems (already derivable):** idempotence, fixpoints on boundaries, gauge erasers, conjugation compatibility; **RNF** pushes `[¬∑]` to leaves and reduces equality to base NF + header policy. These are literal **split‚Äëidempotent boundary projectors**. ÓàÄfileciteÓàÇturn0file1ÓàÅ

---

## 3) Generating Functionals (finite‚Äëproduct; semiring‚Äësafe)

```
Z[J] := ‚ü® ‚äóB_{i‚ààI_fin} ( 1_B ‚äïB Œπ_L(J_i) ‚äóB Obs(i) ) ‚ü©_{Œº,Œ∏} ‚àà L .
```
Moments/cumulants: finite differences in `L`; connected two‚Äëpoint `G(i,j)` and Œ≤‚Äëfields `Œ≤_Œº,Œ≤_Œ∏` as in v2; monotones `a,c` are Lyapunov/Hamiltonians depending on whether you enable an antisymmetric `Œ©` from braided data. ÓàÄfileciteÓàÇturn0file1ÓàÅ

---

## 4) **Umbral Layer** (why this works)

Think of `ŒΩ_L` as an **umbral evaluation**; sources `J` are the **umbrae**; `Z[J]` is the *exponential* generating functional (via finite products, avoiding analysis).

### 4.1 Œî‚Äëoperators and Sheffer system
Define **umbral Œî** on observables by
```
Œî_i T := Z[J]^{-1} ‚äó_L ( Z[J ‚äï Œµ¬∑e_i] ‚äñ_L Z[J] ) |_{Œµ‚Üí0 in L} ,
```
instantiated with finite differences (the same used for Œ≤‚Äôs). The **Sheffer polynomials** are
```
S_n(i) := Œî_i^n Z[J] |_{J=0}  (Appell when the Œî commute) .
```
Because `NF_{Œº,Œ∏}` acts **only** on headers, Œî‚Äôs commute with core reduction; thus the umbral calculus is *stable under renormalisation*. This is the precise ‚Äúumbral logic‚Äù mechanism: evaluation is `ŒΩ_L`, translation is header reweighting, and the Sheffer system is generated by your `Obs(i)`.

### 4.2 Umbral moments and cumulants
Moments are `m_{i1..ik} := Œî_{i1}‚Ä¶Œî_{ik} Z[J]|_{0}`; connected cumulants are the corresponding umbral cumulants (equal to our finite‚Äëdifference cumulants by construction). No new machinery.

---

## 5) **Renormalisation Conditions (RC) & Choice of Vacuum/Model**

All strong statements (logic‚ÄëGRH, internal NP‚â†coNP) are **model‚Äëconditional**. A **vacuum** is the tuple
```
ùí± := ( L, qmask, R-data, basepoint, Obs|_{I_fin}, Œº, Œ∏, Œµ_Œº, Œµ_Œ∏ ) .
```

Pick **RCs** appropriate to your goals; none are axioms of the core theory‚Äîthey‚Äôre *model requirements*.

### RC‚ÄëU0 (Umbral normalisation)
- `ŒΩ_L(1_B)=1_L` and `ŒΩ_L(Œπ_L(x))=x` (already true).  
- Phase invariance: `ŒΩ_L(x‚äóBœÜ^n)=ŒΩ_L(x)` for all `n‚àà‚Ñ§`; if `scale‚ààqmask`, also `ŒΩ_L(x‚äóBŒõ^n)=ŒΩ_L(x)` for all `n‚â•0` (already true). ÓàÄfileciteÓàÇturn0file1ÓàÅ

### RC‚ÄëU1 (Semigroup RG)
`f_{Œ∏1‚äïŒ∏2}=f_{Œ∏2}‚àòf_{Œ∏1}`, `g_{Œº1‚äïŒº2}=g_{Œº2}‚àòg_{Œº1}` (header flow coheres).

### RC‚ÄëU2 (Local positivity/monotonicity)
`L` is positive (idempotent or ordered) so that `g^F=G` is positive semidefinite; `‚äï_L,‚äó_L` are monotone.

### RC‚ÄëU3 (Boundary Leibniz)
`‚àÇ^L_i(x):=ŒΩ_L(ad_i(Œπ_L x))` satisfies Leibniz on `(L,‚äï_L,‚äó_L)`; same for `R` (turns `ad_i` into derivations after projection).

### RC‚ÄëU4 (Localization)
A small localization of `L` exists where inverses needed for `g_F^{-1}`, traces, and Œî‚Äôs are available (only when you call those routines).

### RC‚ÄëU5 (Fisher self‚Äëadjointness; logic‚ÄëGRH aim)
RG generator `‚Ñã` is self‚Äëadjoint for the Fisher inner product induced by `G` (or skew‚Äëadjoint after normalization), i.e. metric compatibility + `*`‚Äëcompatibility via the conjugation interface.

### RC‚ÄëU6 (Monotone verifiers; NP/coNP aim)
Boundary verifiers `Ver(x,w):=(‚ü®V(x,w)‚ü©_{Œº,Œ∏} ‚â•_L œÑ)` are monotone in witnesses and thresholds; acceptance sets are upward‚Äëclosed in the L‚Äëorder.

### RC‚ÄëU7 (Sheffer regularity)
Œî‚Äëoperators commute on the chosen chart (or the commutator is controlled by braided data) so the Fisher Hessian is integrable (`Œ®` exists).

**Vacuum cookbook (pragmatic choices).**
- *Tropical vacuum:* `L=(‚Ñù‚à™{-‚àû}, max,+)` ‚áí positivity/idempotency, monotone verifiers, strong internal NP‚â†coNP signals.  
- *Log‚Äësum‚Äëexp vacuum:* `L=‚Ñù_{‚â•0}` with `(+ , √ó)` ‚áí genuine Fisher metric; good for logic‚ÄëGRH runs.  
- *Boolean vacuum:* `L={0,1}` ‚áí degenerate Fisher; only use for structural checks.

---

## 6) Spectral Layer: Kernel‚ÄìCokernel & logic‚ÄëZeta

**Verifier operator.** Fix a bulk `V(x,w)`. For a distribution `œÅ` with finite support on witnesses:
```
T_x(œÅ) := ‚ü® V(x, Œπ_L œÅ) ‚ü©_{Œº,Œ∏} ‚àà L .
```
This is L‚Äëlinear and monotone (RC‚ÄëU2/U6). Define **weights** by any monotone size in a localization:
```
K(x):=w_K(ker T_x),   C(x):=w_C(coker T_x).
```
**Internal separation.** Under RC‚ÄëU2/U6 + observer invariance, kernel‚Äìcokernel asymmetry is generic ‚áí **LNP ‚â† coLNP** inside CLEAN (not a classical TM claim).

**Logic‚Äëzeta.** With `T:=‚äï_x T_x`,
```
Œ∂_logic(s) := exp_L( ‚äï_{n‚â•1} (Tr_L(T^n) ‚äò_L n) ‚äó_L s^n )  ‚àà L[[s]] .
```
**logic‚ÄëGRH (internal criterion).** Under RC‚ÄëU4/U5/U7, the following are equivalent:
1. `‚Ñã` is Fisher‚Äëself‚Äëadjoint (or skew after normalization).  
2. Kernel/cokernel balance at stationary moduli (`K=C`).  
3. All zeros of `Œ∂_logic` lie on the **Fisher‚Äëcritical line**.

---

## 7) Moduli / Seibergology ‚Äî **Actionable pipeline**

Fix a finite `I_fin` of observables as coordinates.

**Step M0: Chart & basepoint.** Choose vacuum `ùí±` and a point `(Œº,Œ∏)`; record `g^i := ‚ü®Obs(i)‚ü©`.

**Step M1: Fisher & cumulants.** Compute the **Fisher metric** `g^F_{ij}:=G(i,j)` and **third cumulants** `T_{ijk}` from `Z[J]` by finite differences.

**Step M2: Integrability test.** Check `‚àÇ_i G_{jk} = ‚àÇ_j G_{ik}` (finite‚Äëdifference curls) on the chart. If true, a **prepotential** `Œ®` exists (Hessian geometry).

**Step M3: Prepotential integration.** Fix a spanning tree on the chart; integrate `‚àÇŒ® = Œ£_i g_{D,i} dg^i` with `g_{D,i}:=‚àÇ_iŒ®`. Store affine ambiguity (global constant + linear term).

**Step M4: Discriminant & monodromy.** Form `Œî:=det G` in a localization. When `Œî‚âà0`, mark walls; parallel transport around elementary loops, decide frame changes via braided `F_{ij}` (monodromy).

**Step M5: Connections.** Build **Œ±‚Äëconnections** `Œì^{(Œ±)}_{ijk} = Œì^{(0)}_{ijk} + (1‚àíŒ±)/2¬∑T_{ijk}` (with Levi‚ÄëCivita `Œì^{(0)}` from `g^F`).

**Step M6: Curvature & invariants.** Compute `Ric`, `R`, and the **de‚ÄØSitter invariant** `I_dS := (1/d)R|_{Œ≤=0}` and `Œõ_mod := max(0,I_dS)`.

**Step M7: Einstein‚ÄìCLEAN equation.**
```
E_{ij} := Ric_{ij} ‚àí ¬Ω R g^F_{ij} ‚àí Œõ_mod g^F_{ij} ‚àí ‚àÇ_i‚àÇ_j ùîâ = 0 ,
```
with `ùîâ‚àà{a,c}` (your monotones). Solve/diagnose along RG trajectories.

> *Notes.* All derivatives are finite differences; inverses are taken in a localization (RC‚ÄëU4). Monodromy uses your `F_{ij}`; no new primitives.

---

## 8) APIs (additions; all thin wrappers)

```racket
;; Vacuum/model selection
(choose-vacuum!
  #:L <carrier>           ; module implementing ‚äï_L, ‚äó_L, order, localization
  #:qmask '(phase)        ; or '(phase scale)
  #:rdata 'identity       ; or 'triality-g2, 'quat, 'complex
  #:basepoint (list a0 a1 a2 a3)
  #:mu <L> #:theta <L>    ; flow params
  #:eps-mu <L> #:eps-theta <L>)

(set-observables! I_fin list-of-<B-terms>)         ; coordinate choice

;; Umbral layer
(delta i)                       ; Œî_i operator (finite-diff wrapper)
(sheffer i n)                   ; S_n(i) at current vacuum

;; Spectral layer
(define-verifier V)             ; bulk template
(build-T x)                     ; -> operator object
(kernel-weight T) (cokernel-weight T)
(trace-power T n) (zeta-logic T s #:order k)

;; Moduli pipeline
(build-moduli!)                 ; runs M0..M2 and caches g,G,T
(prepotential-exists?)          ; integrability check
(integrate-prepotential!)       ; builds Œ®, returns duals g_D
(discriminant)                  ; localized det G
(monodromy-step loop)           ; apply F_{ij}-driven frame change
(alpha-connection Œ±) (ricci) (scalar-curvature)
(desitter-invariant) (moduli-cosmological-constant)

;; Existing core
(normal-form t) (normal-form-parametric t)
(reflect 'L t) (reflect 'R t) (reflect 'flow t) (rnf t)
(register-observable i <B-term>)
(value g i) (value G i j) (value beta-Œº i) (value beta-Œ∏ i) (value a) (value c)
```

---

## 9) What remains ‚Äúactionably open‚Äù (checklist)

- **Pick a vacuum ùí±** (RC‚ÄëU0..U7); document it in code (one helper call).  
- **Fix a chart** `I_fin` and register observables.  
- **Integrability choice:** if `Œ®` fails on a chart, either (i) use Œ±‚Äëconnections directly (no `Œ®` needed), or (ii) refine the chart until curls vanish numerically.  
- **logic‚ÄëGRH goal:** ensure RC‚ÄëU5 (self‚Äëadjoint ‚Ñã) by making the RG step metric‚Äëcompatible (symmetric header update, *‚Äëcompatible observers).  
- **NP‚â†coNP goal:** ensure RC‚ÄëU2/U6 (positive idempotent `L`, monotone verifiers); pick `œÑ` by calibration.  
- **Localization policy:** decide once (rational closure / valuation); expose to API.

With these choices, the spec is **fully actionable**: every construct has an algorithm and an API hook.

---

## 10) Tests (csh)

```csh
# Choose a vacuum (tropical example; strong internal separation)
logic eval "(choose-vacuum! #:L 'tropical #:qmask '(phase) #:rdata 'identity
                         #:basepoint (list a0 a1 a2 a3) #:mu 0 #:theta 0
                         #:eps-mu 1 #:eps-theta 1)"

# Register a small chart and build moduli
logic eval "(set-observables! '(0 1) (list '(ad 0 (gen4 a0 a1 a2 a3))
                                           '(ad 1 (gen4 a0 a1 a2 a3))))"
logic eval "(build-moduli!)"
logic eval "(fisher-matrix)"
logic eval "(prepotential-exists?)"

# Spectral layer
logic eval "(define-verifier Vtoy)"
logic eval "(define Tx (build-T 'x0))"
logic eval "(kernel-weight Tx)"
logic eval "(cokernel-weight Tx)"
logic eval "(zeta-logic Tx 's #:order 8)"

# Geometry
logic eval "(scalar-curvature)"
logic eval "(desitter-invariant)"
```

---

**End ‚Äî CLEAN v6 Umbral Spectral Edition**.
