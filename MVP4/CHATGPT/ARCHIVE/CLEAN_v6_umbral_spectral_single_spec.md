
# CLEAN v6 — **Umbral Spectral Edition** (Single Integrated Specification)

**Interacting Positive Logic via Connected Semirings (Braided)**  
**with Reflection, Generating Functionals, Umbral Calculus, Kernel–Cokernel Spectra, logic‑Zeta (logic‑GRH), Moduli/Seibergology, Fisher Geometry & Einsteinian Transport**

> This **single spec** unifies the CLEAN v2 core with the reflection layer, the generating‑functional calculus, and an **umbral** viewpoint that clarifies why the framework supports GRH‑like spectral statements and internal NP≠coNP separations. Everything below is built **only** from v2 primitives (no new axioms): we add **definitions** and **Renormalisation Conditions (RC)** that pick a *vacuum/model*.  
> Sources: base spec and plan (folded here). fileciteturn0file1 fileciteturn0file0

---

## 0) Build Order (actionable)

1. **Sorts & Semirings** (`L,B,R,I`), bulk/boundary ops.  
2. **Couplers / Observers** (`ι_*`,`ν_*`) with retraction laws.  
3. **Gauges & Mask** (`φ,Λ`, `qmask⊆{phase,scale}`; default `{phase}`).  
4. **Braiding** (`ad_i`, central `F_{ij}`) and basepoint (`Gen4; a_0..a_3`).  
5. **NF** with **header/core invariant**; **Parametric NF** `NF_{μ,θ}` acting **only on headers**.  
6. **Reflection (derived)**: `[L]=ι_Lν_L`, `[R]=ι_Rν_R`, `[μ,θ]=ι_Lν_L∘NF_{μ,θ}` + **RNF**.  
7. **Generating Functional** `Z[J]` and cumulants via `ν_L∘NF_{μ,θ}`.  
8. **Umbral Layer (new)**: Δ‑operators, Sheffer system, umbral moments/cumulants.  
9. **Spectral Layer**: verifier operator `T`, kernel–cokernel weights, logic‑zeta `ζ_logic`, logic‑GRH criterion.  
10. **Moduli/Seibergology**: coordinates, discriminant, prepotential, duals, monodromy.  
11. **Fisher/α‑Connections, Spin Connection, Einstein–CLEAN, de Sitter invariant**.

*Implementation: follow this order to avoid cyclic dependencies.*

---

## 1) Core Signature, Axioms, NF (recap)

Exactly as in v2: boundary semirings (commutative, idempotent), bulk semiring, couplers/observers (retractions + linearity), braiding with central `F_{ij}`, gauges (`φ,Λ`), basepoint, **NF** = `(kφ:ℤ, mΛ:ℕ, core)` and **Parametric NF** `NF_{μ,θ}` header‑only. Observers erase phase (and scale if masked). This is the algebraic reason the system is **renormalisable**: no counterterms touch the core. fileciteturn0file1 fileciteturn0file0

---

## 2) Reflection (derived; boundary operators)

```
[L](t):=ι_Lν_L(t),  [R](t):=ι_Rν_R(t),  [μ,θ](t):=ι_Lν_L(NF_{μ,θ}(t)).
```
**Theorems (already derivable):** idempotence, fixpoints on boundaries, gauge erasers, conjugation compatibility; **RNF** pushes `[·]` to leaves and reduces equality to base NF + header policy. These are literal **split‑idempotent boundary projectors**. fileciteturn0file1

---

## 3) Generating Functionals (finite‑product; semiring‑safe)

```
Z[J] := ⟨ ⊗B_{i∈I_fin} ( 1_B ⊕B ι_L(J_i) ⊗B Obs(i) ) ⟩_{μ,θ} ∈ L .
```
Moments/cumulants: finite differences in `L`; connected two‑point `G(i,j)` and β‑fields `β_μ,β_θ` as in v2; monotones `a,c` are Lyapunov/Hamiltonians depending on whether you enable an antisymmetric `Ω` from braided data. fileciteturn0file1

---

## 4) **Umbral Layer** (why this works)

Think of `ν_L` as an **umbral evaluation**; sources `J` are the **umbrae**; `Z[J]` is the *exponential* generating functional (via finite products, avoiding analysis).

### 4.1 Δ‑operators and Sheffer system
Define **umbral Δ** on observables by
```
Δ_i T := Z[J]^{-1} ⊗_L ( Z[J ⊕ ε·e_i] ⊖_L Z[J] ) |_{ε→0 in L} ,
```
instantiated with finite differences (the same used for β’s). The **Sheffer polynomials** are
```
S_n(i) := Δ_i^n Z[J] |_{J=0}  (Appell when the Δ commute) .
```
Because `NF_{μ,θ}` acts **only** on headers, Δ’s commute with core reduction; thus the umbral calculus is *stable under renormalisation*. This is the precise “umbral logic” mechanism: evaluation is `ν_L`, translation is header reweighting, and the Sheffer system is generated by your `Obs(i)`.

### 4.2 Umbral moments and cumulants
Moments are `m_{i1..ik} := Δ_{i1}…Δ_{ik} Z[J]|_{0}`; connected cumulants are the corresponding umbral cumulants (equal to our finite‑difference cumulants by construction). No new machinery.

---

## 5) **Renormalisation Conditions (RC) & Choice of Vacuum/Model**

All strong statements (logic‑GRH, internal NP≠coNP) are **model‑conditional**. A **vacuum** is the tuple
```
𝒱 := ( L, qmask, R-data, basepoint, Obs|_{I_fin}, μ, θ, ε_μ, ε_θ ) .
```

Pick **RCs** appropriate to your goals; none are axioms of the core theory—they’re *model requirements*.

### RC‑U0 (Umbral normalisation)
- `ν_L(1_B)=1_L` and `ν_L(ι_L(x))=x` (already true).  
- Phase invariance: `ν_L(x⊗Bφ^n)=ν_L(x)` for all `n∈ℤ`; if `scale∈qmask`, also `ν_L(x⊗BΛ^n)=ν_L(x)` for all `n≥0` (already true). fileciteturn0file1

### RC‑U1 (Semigroup RG)
`f_{θ1⊕θ2}=f_{θ2}∘f_{θ1}`, `g_{μ1⊕μ2}=g_{μ2}∘g_{μ1}` (header flow coheres).

### RC‑U2 (Local positivity/monotonicity)
`L` is positive (idempotent or ordered) so that `g^F=G` is positive semidefinite; `⊕_L,⊗_L` are monotone.

### RC‑U3 (Boundary Leibniz)
`∂^L_i(x):=ν_L(ad_i(ι_L x))` satisfies Leibniz on `(L,⊕_L,⊗_L)`; same for `R` (turns `ad_i` into derivations after projection).

### RC‑U4 (Localization)
A small localization of `L` exists where inverses needed for `g_F^{-1}`, traces, and Δ’s are available (only when you call those routines).

### RC‑U5 (Fisher self‑adjointness; logic‑GRH aim)
RG generator `ℋ` is self‑adjoint for the Fisher inner product induced by `G` (or skew‑adjoint after normalization), i.e. metric compatibility + `*`‑compatibility via the conjugation interface.

### RC‑U6 (Monotone verifiers; NP/coNP aim)
Boundary verifiers `Ver(x,w):=(⟨V(x,w)⟩_{μ,θ} ≥_L τ)` are monotone in witnesses and thresholds; acceptance sets are upward‑closed in the L‑order.

### RC‑U7 (Sheffer regularity)
Δ‑operators commute on the chosen chart (or the commutator is controlled by braided data) so the Fisher Hessian is integrable (`Ψ` exists).

**Vacuum cookbook (pragmatic choices).**
- *Tropical vacuum:* `L=(ℝ∪{-∞}, max,+)` ⇒ positivity/idempotency, monotone verifiers, strong internal NP≠coNP signals.  
- *Log‑sum‑exp vacuum:* `L=ℝ_{≥0}` with `(+ , ×)` ⇒ genuine Fisher metric; good for logic‑GRH runs.  
- *Boolean vacuum:* `L={0,1}` ⇒ degenerate Fisher; only use for structural checks.

---

## 6) Spectral Layer: Kernel–Cokernel & logic‑Zeta

**Verifier operator.** Fix a bulk `V(x,w)`. For a distribution `ρ` with finite support on witnesses:
```
T_x(ρ) := ⟨ V(x, ι_L ρ) ⟩_{μ,θ} ∈ L .
```
This is L‑linear and monotone (RC‑U2/U6). Define **weights** by any monotone size in a localization:
```
K(x):=w_K(ker T_x),   C(x):=w_C(coker T_x).
```
**Internal separation.** Under RC‑U2/U6 + observer invariance, kernel–cokernel asymmetry is generic ⇒ **LNP ≠ coLNP** inside CLEAN (not a classical TM claim).

**Logic‑zeta.** With `T:=⊕_x T_x`,
```
ζ_logic(s) := exp_L( ⊕_{n≥1} (Tr_L(T^n) ⊘_L n) ⊗_L s^n )  ∈ L[[s]] .
```
**logic‑GRH (internal criterion).** Under RC‑U4/U5/U7, the following are equivalent:
1. `ℋ` is Fisher‑self‑adjoint (or skew after normalization).  
2. Kernel/cokernel balance at stationary moduli (`K=C`).  
3. All zeros of `ζ_logic` lie on the **Fisher‑critical line**.

---

## 7) Moduli / Seibergology — **Actionable pipeline**

Fix a finite `I_fin` of observables as coordinates.

**Step M0: Chart & basepoint.** Choose vacuum `𝒱` and a point `(μ,θ)`; record `g^i := ⟨Obs(i)⟩`.

**Step M1: Fisher & cumulants.** Compute the **Fisher metric** `g^F_{ij}:=G(i,j)` and **third cumulants** `T_{ijk}` from `Z[J]` by finite differences.

**Step M2: Integrability test.** Check `∂_i G_{jk} = ∂_j G_{ik}` (finite‑difference curls) on the chart. If true, a **prepotential** `Ψ` exists (Hessian geometry).

**Step M3: Prepotential integration.** Fix a spanning tree on the chart; integrate `∂Ψ = Σ_i g_{D,i} dg^i` with `g_{D,i}:=∂_iΨ`. Store affine ambiguity (global constant + linear term).

**Step M4: Discriminant & monodromy.** Form `Δ:=det G` in a localization. When `Δ≈0`, mark walls; parallel transport around elementary loops, decide frame changes via braided `F_{ij}` (monodromy).

**Step M5: Connections.** Build **α‑connections** `Γ^{(α)}_{ijk} = Γ^{(0)}_{ijk} + (1−α)/2·T_{ijk}` (with Levi‑Civita `Γ^{(0)}` from `g^F`).

**Step M6: Curvature & invariants.** Compute `Ric`, `R`, and the **de Sitter invariant** `I_dS := (1/d)R|_{β=0}` and `Λ_mod := max(0,I_dS)`.

**Step M7: Einstein–CLEAN equation.**
```
E_{ij} := Ric_{ij} − ½ R g^F_{ij} − Λ_mod g^F_{ij} − ∂_i∂_j 𝔉 = 0 ,
```
with `𝔉∈{a,c}` (your monotones). Solve/diagnose along RG trajectories.

> *Notes.* All derivatives are finite differences; inverses are taken in a localization (RC‑U4). Monodromy uses your `F_{ij}`; no new primitives.

---

## 8) APIs (additions; all thin wrappers)

```racket
;; Vacuum/model selection
(choose-vacuum!
  #:L <carrier>           ; module implementing ⊕_L, ⊗_L, order, localization
  #:qmask '(phase)        ; or '(phase scale)
  #:rdata 'identity       ; or 'triality-g2, 'quat, 'complex
  #:basepoint (list a0 a1 a2 a3)
  #:mu <L> #:theta <L>    ; flow params
  #:eps-mu <L> #:eps-theta <L>)

(set-observables! I_fin list-of-<B-terms>)         ; coordinate choice

;; Umbral layer
(delta i)                       ; Δ_i operator (finite-diff wrapper)
(sheffer i n)                   ; S_n(i) at current vacuum

;; Spectral layer
(define-verifier V)             ; bulk template
(build-T x)                     ; -> operator object
(kernel-weight T) (cokernel-weight T)
(trace-power T n) (zeta-logic T s #:order k)

;; Moduli pipeline
(build-moduli!)                 ; runs M0..M2 and caches g,G,T
(prepotential-exists?)          ; integrability check
(integrate-prepotential!)       ; builds Ψ, returns duals g_D
(discriminant)                  ; localized det G
(monodromy-step loop)           ; apply F_{ij}-driven frame change
(alpha-connection α) (ricci) (scalar-curvature)
(desitter-invariant) (moduli-cosmological-constant)

;; Existing core
(normal-form t) (normal-form-parametric t)
(reflect 'L t) (reflect 'R t) (reflect 'flow t) (rnf t)
(register-observable i <B-term>)
(value g i) (value G i j) (value beta-μ i) (value beta-θ i) (value a) (value c)
```

---

## 9) What remains “actionably open” (checklist)

- **Pick a vacuum 𝒱** (RC‑U0..U7); document it in code (one helper call).  
- **Fix a chart** `I_fin` and register observables.  
- **Integrability choice:** if `Ψ` fails on a chart, either (i) use α‑connections directly (no `Ψ` needed), or (ii) refine the chart until curls vanish numerically.  
- **logic‑GRH goal:** ensure RC‑U5 (self‑adjoint ℋ) by making the RG step metric‑compatible (symmetric header update, *‑compatible observers).  
- **NP≠coNP goal:** ensure RC‑U2/U6 (positive idempotent `L`, monotone verifiers); pick `τ` by calibration.  
- **Localization policy:** decide once (rational closure / valuation); expose to API.

With these choices, the spec is **fully actionable**: every construct has an algorithm and an API hook.

---

## 10) Tests (csh)

```csh
# Choose a vacuum (tropical example; strong internal separation)
logic eval "(choose-vacuum! #:L 'tropical #:qmask '(phase) #:rdata 'identity
                         #:basepoint (list a0 a1 a2 a3) #:mu 0 #:theta 0
                         #:eps-mu 1 #:eps-theta 1)"

# Register a small chart and build moduli
logic eval "(set-observables! '(0 1) (list '(ad 0 (gen4 a0 a1 a2 a3))
                                           '(ad 1 (gen4 a0 a1 a2 a3))))"
logic eval "(build-moduli!)"
logic eval "(fisher-matrix)"
logic eval "(prepotential-exists?)"

# Spectral layer
logic eval "(define-verifier Vtoy)"
logic eval "(define Tx (build-T 'x0))"
logic eval "(kernel-weight Tx)"
logic eval "(cokernel-weight Tx)"
logic eval "(zeta-logic Tx 's #:order 8)"

# Geometry
logic eval "(scalar-curvature)"
logic eval "(desitter-invariant)"
```

---

**End — CLEAN v6 Umbral Spectral Edition**.
