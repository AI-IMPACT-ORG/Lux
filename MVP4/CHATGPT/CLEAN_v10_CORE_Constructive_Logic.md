
# CLEAN v10 — **Core Constructive Logic** (Triality; Bulk as Two Boundaries)

> Minimal, implementation-ready **global logic**. Triality is explicit and the **bulk decomposes into the two boundaries** (precisely: the bulk observable content equals the sum of boundary images; residual core is invisible to both observers). This file **does not** include guarded negation or domain maps; those live in the CLASS spec. All new features remain **definitions** over the v2 primitives and axioms.

---

## 0) Scope and dependencies

- **Depends on the v2 core**: boundary & bulk semirings, couplers/observers (retractions), braided `ad_i`, central scalars `φ, z, barz`, `Λ := z ⊗B barz`, basepoint `Gen4(a_0,…,a_3)=0_B`, and the **header/core NF** with parametric variant.  
- **Triality layer**: typed conjugations `starB, starL, starR` and triality functors `T_L, T_R, T_B`.  
- **Bulk = Two Boundaries**: formal **reconstitution** by boundary projectors with an interaction residual that is erased by both observers.

*(Everything here is definitional on top of v2; no new axioms are introduced.)*

---

## 1) Signature fragment (recap & additions)

- **Sorts**: `L, B, R, I` (unit).  
- **Couplers/observers**: `ι_L, ι_R, ν_L, ν_R` with `ν_*;ι_* = id_*`.  
- **Braiding**: `ad_0..ad_3 : B→B`.
- **Gauges**: `φ : I→B`, `z, \bar{z} : I→B`, `Λ := z ⊗B \bar{z}` (all **central units** per v2).

**Notation.** We freely identify constants `c:B` with arrows `I→B` from the unit sort; this is purely notational and matches the v2/CLASS presentation where `φ,z,\bar{z},a_i` are elements of `B`.  
We sometimes view constants as arrows I→B; I is a notational unit sort only.
No axiom quantifies over I; it merely types elements of the central (φ,z,\bar{z}) subalgebra.  
- **Basepoint**: `a_0..a_3:I→B`, `Gen4:B^4→B`, axiom `Gen4(a_0,…,a_3)=0_B`.  
- **Triality ops (derived)**: `starB:B→B`, `starL:L→L`, `starR:R→R` (typed conjugations).  
- **Operators & projectors (derived)**: `[L](t):=ι_Lν_L(t)`, `[R](t):=ι_Rν_R(t)`,
`[μ,θ](t):=ι_Lν_L(NF^{B}_{μ,θ}(t))` (a **modulated projector**; in general **not** idempotent unless `f_θ, g_μ` fix headers).

**Parameters μ,θ act as header endomorphisms.** Their effects are realised in B by central
multiplication in the auxiliary moduli (φ,z,\bar{z}) via NF^B_{μ,θ}. The four boundary
instances (μ_L,θ_L,μ_R,θ_R) are fixed in CLASS.

**Parametric NF (recap)**: if `NF(t)=(kφ:ℤ, mΛ:ℤ, core(t))`, then  
`NF_{μ,θ}(t) := ( f_θ(kφ), g_μ(mΛ), core(t) )` with `f_θ:ℤ→ℤ`, `g_μ:ℤ→ℤ` (**expanding, neutral, contracting** allowed; header-only).


**B‑valued normaliser (definitional; header‑only).**  
If `NF(t)=(kφ:ℤ, mΛ:ℤ, core(t))`, define
\[
NF^{B}_{\mu,\theta}(t) \;:=\; \phi^{\,f_{\theta}(k_\phi)}\;\otimes_B\; \Lambda^{\,g_{\mu}(m_\Lambda)}\;\otimes_B\; core(t)
\]
so `NF^{B}_{μ,θ}:B→B` is **well‑typed** and leaves `core(t)` untouched. The tuple‑valued `NF_{μ,θ}` remains available for analyses.
**Flow‑compatibility (RC).** Require `f_{θ_1⊕θ_2}=f_{θ_2}∘f_{θ_1}` on `(ℤ,+)` and
`g_{μ_1⊕μ_2}=g_{μ_2}∘g_{μ_1}` on `(ℤ,+)`. Then `NF^{B}_{μ,θ}` acts as a semiring
**endomorphism** on the central header subalgebra generated by `φ,Λ`.
(Note) Scale increments may be split to (Δm_z,Δm_{\bar{z}}) via the R‑data matrix; see CLASS §5.



---

## 2) Triality & decomposition

**Triality functors (derived):**
- `T_L(t) := ν_L(t)` (bulk→left), `T_R(t) := ν_R(t)`, `T_B(x_L,x_R) := ι_L(x_L) ⊕B ι_R(x_R)`.

**Conjugations (typed; optional RC).** starB acts on headers by
  (k_φ, m_z, m_{\bar{z}}) ↦ (k_φ, m_{\bar{z}}, m_z)  (φ fixed; z↔\bar{z}),
and is an anti-involution on ⊗_B; starL,starR are induced on L,R so that
  starB(ι_L x)=ι_L(starL x), starB(ι_R y)=ι_R(starR y).
On moduli: star swaps (μ_L,θ_L) ↔ (μ_R,θ_R). Results here do not require star*.

**Reconstitution map (bulk = two boundaries):**
\[
\rho(t) \;:=\; [L](t) \;⊕_B\; [R](t) \;\in \; \mathrm{im}(ι_L) ⊕_B \mathrm{im}(ι_R).
\]
**Residual**: `int(t) := t ⊕B ρ(t)` (no subtraction needed). Because `NF` collapses
`m_z,m_{\bar z}` to `m_Λ`, there is **no canonical inverse**; the residual is just the
tagged difference, not obtained by "splitting" NF.

**Decomposition Theorem (observer form).** For all `t:B`,
\[
ν_L(t) \;=\; ν_L([L](t) ⊕_B [R](t)), \qquad
ν_R(t) \;=\; ν_R([L](t) ⊕_B [R](t)) .
\]
*Hence the **observable bulk** equals the **sum of the two boundaries***; more cautiously, for the residual we have the **observer‑equality**
`ν_*(int(t)) = ν_*(t) ⊕_* ν_*(t)` with `x:=ν_*(t)=ν_*(ρ(t))`. This equals `0_*` **only** in models where duplicates annihilate (e.g., characteristic‑2); in idempotent semirings it equals `x`.

**Equality corollary.** Modulo the active mask `≡_qmask`, if observers are **jointly faithful** on your model class, then `t ≡_qmask ρ(t)` (bulk collapses to its boundary sum in equality tests).

---

## 3) Generating functional & cumulants (recap)

For finite set `I_fin ⊆ I`:
\[
Z[J] := ⟨ \bigotimes_{i∈I_{fin}} (1_B ⊕_B ι_L(J_i) ⊗_B Obs(i)) ⟩_{μ,θ} \in L.
\]
Couplings `g(i)`, connected `G(i,j)`, β-fields, monotones `a,c` as in the v2 spec (definitionally via `ν_L ∘ NF_{μ,θ}`).

---

## 4) Unit tests (core)

```csh
# Masks & triality set-up
logic eval "(set-quotient-mask! '(phase))"
logic eval "(define x '(ad 0 (gen4 a0 a1 a2 a3)))"
logic eval "(define y '(ad 1 (gen4 a0 a1 a2 a3)))"

# RNF idempotence of projectors
logic eval "(equal? 'B '([L] ([L] x)) '([L] x))"      # -> #t
logic eval "(equal? 'B '([R] ([R] y)) '([R] y))"      # -> #t

# Bulk = two boundaries (observer equalities)
logic eval "(equal? 'L '(ν_L x) '(ν_L (⊕B ([L] x) ([R] x))))"   # -> #t
logic eval "(equal? 'R '(ν_R x) '(ν_R (⊕B ([L] x) ([R] x))))"   # -> #t

# Residual invisibility (model‑dependent)
logic eval "(define intx '(⊕B x (⊕B ([L] x) ([R] x))))"         # tagged residual
; General law (always): ν_*(intx) = ν_*(x) ⊕_* ν_*(x)
logic eval "(equal? 'L '(ν_L intx) '(⊕_L (ν_L x) (ν_L x)))"      # -> #t
logic eval "(equal? 'R '(ν_R intx) '(⊕_R (ν_R x) (ν_R x)))"      # -> #t
; Optional: gate "residual→0_*" behind a port or mask
; logic eval "(set-qmask! '(phase parity))"          ; quotient by phase parity if desired
; logic eval "(port-boolean #:addition 'xor)"        ; OR: choose a port with duplicate-annihilation
; logic eval "(when (port-dup-annihilates?) (equal? 'L '(ν_L intx) '0_L))"  ; gated

# Conjugation interface
logic eval "(equal? 'B '(starB (ι_L 1_L)) '(ι_L (starL 1_L)))"  # -> #t

# Cumulant sanity
logic eval "(register-observable 0 x)"
logic eval "(value g 0)"
logic eval "(value G 0 0)"

# B-valued NF is header-only and well-typed (integer scale)
logic eval "(define t '(⊗B (φ^ 2) (⊗B (Λ^ 5) coreX)))"
logic eval "(equal? 'B '(NF^B t) '(⊗B (φ^ (fθ 2)) (⊗B (Λ^ (gμ 5)) coreX)))"   ; gμ may return negative

# Projector via NF^B is B→B
logic eval "(equal? 'B '([μθ] t) '(ι_L (ν_L (NF^B t))))"
```

---

## 5) Notes

- This core is **constructive** (no global negation). Guarded negations, domain ports, PSDM and Feynman view are layered in the CLASS file.  
- Triality and the boundary sum property are **definitions over** observers and NF and hold in every v2‑model.

*End Core.*
