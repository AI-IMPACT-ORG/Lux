
# CLEAN v10 â€” **CLASS** (Complete Language Spec)
**Dependent on four core moduli and two auxiliary moduli**

> A programming-language style specification layered on the v10 Core.  
> **Four core moduli:** \( Î¼_L, Î¸_L, Î¼_R, Î¸_R \) (left/right scale & phase flows).  
> **Two auxiliary moduli:** \( z, \bar z \) (define \(Î› := z âŠ—_B \bar z\)) (all **central units** per v2).  
> This file adds: **guarded negation**, **domain ports** (Boolean/RAM, Î»â€‘calc, infoâ€‘flow, nonâ€‘susy QFT), **PSDM** (irreversibility), **Feynman** view, and **integration tests** ("truth theorems").

**Tokens.**  \bar{z} â†” barz,  dec_{z\bar{z}} â†” dec_{zbar},  âŠ•_B â†” +B,  âŠ—_B â†” *B,
          ð“œ_{â€¦} â†” M(Î”k,Î”mz,Î”mbarz),  Ëœadáµ¢ â†” Madáµ¢.

---

## 0) Dependencies & minimality

- Builds on **v10 Core** (triality, boundary sum, cumulants) and thus on the **v2 base** (no new axioms; all additions are **definitions** or **model RCs**).  
- Minimal to **internalise its own compiler generator**: encodings TMâ†”Î» via the generating functional; PSDM yields partial/irreversible semantics; guarded negation yields local NAND.  
- Avoids collapse to known models: irreversibility is confined to PSDM/domain; global logic remains constructive.

---

## 1) Moduli, parameters, and flows

**Core moduli (4):** \( Î¼_L, Î¸_L, Î¼_R, Î¸_R \in L \).  
**Auxiliary (2):** \( z, \bar{z} \in B \) with \(Î› := z âŠ—_B \bar{z}\).  
*Notation.* We write `\bar{z}` in formulas and use the ASCII token `barz` in code/API
identifiers when needed; similarly `dec_{z\bar{z}}` may appear as `dec_{zbar}` in code.
**Other parameters:** `qmask` (default `(phase)`), Râ€‘data preset (e.g., `identity`, `triality-g2`).

### 1.1 Boundaryâ€‘aware parametric NF (integer headers)
Let `NF(t)=(kÏ†, mÎ›, core)`. Define local headers:
\[
k^L_\phi := \mathrm{phase}(\mathrm{NF}([L]t)), \quad
k^R_\phi := \mathrm{phase}(\mathrm{NF}([R]t)), \quad
m^L_\Lambda := \mathrm{scale}(\mathrm{NF}([L]t)), \quad
m^R_\Lambda := \mathrm{scale}(\mathrm{NF}([R]t)).
\]
Then the **fourâ€‘moduli parametric normaliser** is
\[
NF_{Î¼_L,Î¸_L, Î¼_R,Î¸_R}(t) := \big( f_{Î¸_L}(k^L_\phi) âŠ• f_{Î¸_R}(k^R_\phi),\; g_{Î¼_L}(m^L_\Lambda) âŠ• g_{Î¼_R}(m^R_\Lambda),\; core(t) \big)
\]
with `âŠ•` the header recombination (**integer addition** for both phase and scale; expanding, neutral, contracting allowed).

**Flow compatibility (RC):** \( f_{Î¸_1âŠ•Î¸_2}=f_{Î¸_2}\circ f_{Î¸_1} \) and \( g_{Î¼_1âŠ•Î¼_2}=g_{Î¼_2}\circ g_{Î¼_1} \) for each boundary (semigroup law on \(â„¤\)).


### 1.1â€² Bâ€‘valued boundaryâ€‘aware normaliser *(definitional; headerâ€‘only; integer scale)*

With local headers
`k^L_Ï†, k^R_Ï†, m^L_Î›, m^R_Î›` as above, define
\[
NF^{B}_{\mu_L,\theta_L,\mu_R,\theta_R}(t)
+:=\;
\phi^{\,f_{\theta_L}(k^L_\phi)+f_{\theta_R}(k^R_\phi)}
\;\otimes_B\;
\Lambda^{\,g_{\mu_L}(m^L_\Lambda)+g_{\mu_R}(m^R_\Lambda)}
\;\otimes_B\; core(t).
\]
This mirrors Â§1.1 but **returns an element of** `B` and leaves `core(t)` untouched.
(Default recombination is **integer addition** for both phase and scale exponents; expanding, neutral, contracting allowed.)

**Auxiliary transporter (definitional).** Define the central, headerâ€‘only "transporter"
\[
\mathcal M_{(\Delta k,\Delta m_z,\Delta m_{\bar{z}})}(t)
\;:=\; \phi^{\Delta k}\otimes_B z^{\Delta m_z}\otimes_B \bar{z}^{\Delta m_{\bar{z}}}\otimes_B t,
\]
which acts *only* on the header subalgebra generated by \((\phi,z,\bar{z})\); it leaves `core(t)` unchanged (by v2's exp/log split). This is definitional; it does **not** alter A5's statement that `adáµ¢` preserves headers.

**Port coherence (RC).** Every domain port `Port` with PSDM `ð’Ÿ^â™¯` satisfies:
- **Observational invariance:** `ð’Ÿ_Port âˆ˜ NF^{B}_{Î¼_*,Î¸_*} = ð’Ÿ_Port` on their common domain (header gaugeâ€‘fix is observationally inert).
- **Domain invariance (partiality preserved):** `Dom(ð’Ÿ^â™¯) = Dom(ð’Ÿ^â™¯ âˆ˜ NF^{B}_{Î¼_*,Î¸_*})`.

**Unit tests.**
```csh
# Boundary-aware B-valued NF returns an element of B
logic eval "(define t '(âŠ—B (ad 0 (gen4 a0 a1 a2 a3)) (ad 1 (gen4 a0 a1 a2 a3))))"
logic eval "(well-typed? 'B '(NF^B-4mod t))"   # -> #t

# PSDM partiality unaffected
logic eval "(define-psdm! #:L-map 'lambda #:B-map 'syntax #:R-map 'unit
                         #:totality 'beta-normalises? #:valuation 'size)"
logic eval "(equal? 'Bool '(psdm-defined? t) '(psdm-defined? (NF^B-4mod t)))"  ; -> #t

# Port output invariant (to truncation)
logic eval "(equal? 'L '(psdm-apply t) '(psdm-apply (NF^B-4mod t)))"           ; -> #t
```



---

## 2) Guarded negation (local NAND; global constructivity)

For any **guard** \(g\in L\) define the principal ideal \(â†“g=\{x\le g\}\).  
**RCâ€‘GN:** a **relative complement** \(gâŠ–_L x\) exists on \(â†“g\). Define guarded negation \(Â¬^g(x):=gâŠ–_L x\).  
Then \( \mathrm{NAND}(x,y) := Â¬^g(x âŠ—_L y) \) gives **local computational universality** without global classical negation.

---

## 3) Domain ports (internally maximally coherent)

A **domain port** \( \mathsf{Port} \) is a (partial) interpretation of carriers & constructors that **commutes** with core definitional machinery (NF, observers, cumulants, Î”) and respects truncation and regulator limits.

### 3.1 Boolean/RAM port (irreversible computing)
- **Carrier:** \(L_0 = \{0,1\}\) or \( \mathbb R_{\ge 0}\) with threshold.  
- **Encoding:** programs as `Obs` and transitions as microâ€‘steps; acceptance via \(Î½_L âˆ˜ NF\).  
- **PSDM:** partial, stable; defined iff program halts within regulator window; otherwise **undefined**.
- **Coherence:** TM and Î» encodings produce identical \(Z[J]\) upstairs; port sees the same Boolean outcome (Churchâ€“Turing inside).

### 3.2 Î»â€‘calculus port
- **Carrier:** normal forms in a typed Î»â€‘fragment; Î²â€‘steps as microâ€‘steps; evaluation via expectations.  
- **PSDM:** defined iff Î²â€‘normalises in the regulator; undefined otherwise.

### 3.3 Infoâ€‘flow port (irreversible information)
- **Carrier:** preorders/lattices; `âŠ•_L` joins, `âŠ—_L` flows; guarded negation yields relative complement; PSDM drops nonâ€‘flow paths.

### 3.4 Nonâ€‘susy QFT port (Euclidean/Minkowski)
- **Carrier:** \(L_E=\mathbb R_{\ge0}\) (Euclidean) or \(L_M=\mathbb C\) (Minkowski).  
- **Feynman view:** histories from microâ€‘steps; action = product of header weights; amplitudes via domain evaluation; propagator = inverse Fisher; vertices = cumulants.

All ports **reuse the same core pipeline**; coherence is by construction.

- **Minimal obligation (definitional).** A port \(\mathsf{Port}\) fixes a **carrier** and supplies a **transition** \(\llbracket K \rrbracket_{\mathsf{Port}}\) for its kernel on that carrier. It must respect headerâ€‘only \(NF_{Î¼_*,Î¸_*}\) and **RCâ€“ME** (residual invisibility); no identification of bulk residual with boundary data is permitted.

---

## 4) PSDM (Partial Stable Domain Map) â€” irreversible semantics

A **PSDM** \( \mathcal D^\sharp \) is:
1) **total** on each regulated fragment; commutes with NF/Î”/cumulants to truncation,  
2) **stable** under regulator inclusions,  
3) **partial** in the direct limit (undefined on nonâ€‘total instances),  
4) **continuous** when RG is contractive.

This realizes **irreversible computation** cleanly while the **global logic remains constructive**.

*A practical hook:* each **domain port** furnishes the kernel's **transition** via its PSDM instance on the chosen carrier; totality/partiality and regulator behaviour remain exactly as specified here.

---

## 5) Feynman / Sumâ€‘overâ€‘Histories (class faÃ§ade)
 
- **Histories (state + weight):** sequences of **braid steps** with labels `(adáµ¢ ; wáµ¢)`, consistent with sources.
  * State update: `adáµ¢ : Bâ†’B` (braid action per v2; headers unchanged).
  * Step weight (central; integer headers): 
    ```
    wáµ¢ := Ï†^{Î”káµ¢} âŠ—_B z^{Î”m_záµ¢} âŠ—_B barz^{Î”m_{barz}áµ¢},      Î”káµ¢,Î”m_záµ¢,Î”m_{barz}áµ¢ âˆˆ â„¤.
    ```
    Scale increments split by **Râ€‘data**:
    ```
    [Î”m_záµ¢, Î”m_{barz}áµ¢]^T = R Â· [ Î”m^L_Î›áµ¢, Î”m^R_Î›áµ¢ ]^T
    ```
    with `Î”m^L_Î›áµ¢ := g_{Î¼_L}(m^L_Î›) âˆ’ m^L_Î›`, `Î”m^R_Î›áµ¢ := g_{Î¼_R}(m^R_Î›) âˆ’ m^R_Î›`.
    **Râ€‘data constraint:** integer entries with column sums = 1 (preserves total scale delta).
    Phase increment:
    ```
    Î”káµ¢ := f_{Î¸_L}(k^L_Ï†) âˆ’ k^L_Ï†  +  f_{Î¸_R}(k^R_Ï†) âˆ’ k^R_Ï†  âˆˆ â„¤.
    ```
  * **Action** along a history: `S(H) := âŠ—_{sâˆˆH} w_s` (central product).
  * **Partition function (definitional):** `Z[J] = âŠ•_{H} S(H)` equals the core cumulant/Green's evaluation to the same truncation.

- **Schwingerâ€“Dyson:** \( âŸ¨Î”_i FâŸ© = 0 \) (umbral integration by parts).  
- **Duality:** midâ€‘grade reflection implements the `zâ†¦1âˆ’z` flavor along boundary flows.

- **Equivalence (definitional).** With \(K\) the microâ€‘step kernel, the "sum over histories" is the **truncated Green's sum** \(G_N=\bigoplus_{n=0}^N K^n\); cumulants and Schwingerâ€“Dyson identities are unchanged and evaluate observers of \(G_N\) exactly as in the core layer.

---

## 6) Truth theorems (integration tests)

1) **Bulk = Two Boundaries (observer equality).** For all `t`,
   \( Î½_*(t) = Î½_*([L]t âŠ•_B [R]t) \) for `*âˆˆ{L,R}` (core theorem; already unitâ€‘tested).

2) **Umbralâ€“Renormalisation (Î” commutes with NF).** Î”â€‘operators generated by finite differences commute with `NF_{Î¼_*,Î¸_*}`; cumulants are schemeâ€‘stable.

3) **Churchâ†”Turing inside CLEAN.** TM and Î» encodings yield the same `Z[J]` and hence identical expectations; under any PSDM the halting/normalising outputs agree (partial equality).

4) **EOR (each object represented once).** With header/core/ braid faithfulness, the (P)SDM/domain map is injective on objects modulo mask; no aliasing.

5) **logicâ€‘Î¶ criticalâ€‘line equivalence (internal).** Fisher selfâ€‘adjoint RG generator â‡” kernelâ€“cokernel balance at stationary moduli â‡” zeros on the Fisherâ€‘critical line. (Ported to QFT port as functionalâ€‘equation symmetry to truncation order.)

---

## 7) Racket folder structure (suggested)

**Public API shims.**
```racket
;; B-valued normalisers (header-only)
(normal-form-B t)            ; NF^{B}_{Î¼,Î¸} : B â†’ B   (Core-level)
(normal-form-B-4mod t)       ; NF^{B}_{Î¼L,Î¸L,Î¼R,Î¸R} : B â†’ B   (CLASS-level)
```


```
clean/
  core/
    signature.rkt          ; sorts, ops, params, qmask, R-data
    axioms.rkt             ; v2 axioms (equational)
    nf.rkt                 ; header/core normaliser
    observers.rkt          ; Î¹, Î½, [L],[R], reconstitution Ï
    triality.rkt           ; starB/starL/starR; triality functors
    cumulants.rkt          ; Z[J], g, G, Î², a, c; Î”-ops
    tests/
      unit-core.rkt        ; the csh-style tests below translated
  class/
    moduli.rkt             ; Î¼_L, Î¸_L, Î¼_R, Î¸_R, z, barz; NF_{â€¦}
    guarded.rkt            ; guarded negation & NAND library
    psdm.rkt               ; partial stable domain map machinery
    feynman.rkt            ; histories, weights, sum, SD identities
    domain/
      boolean/port.rkt
      lambda/port.rkt
      infoflow/port.rkt
      qft/port.rkt
    tests/
      integ-truths.rkt     ; the 5 â€œtruth theoremsâ€ checks
  tooling/
    repl.rkt
    codegen/
      agda.rkt coq.rkt metamath.rkt
```

---

## 8) Public API (Racketâ€‘style faÃ§ade)

```racket
;; --- core (re-exported) ---
(set-quotient-mask! m)
(set-r-matrix! M)
(normal-form t)                         ; -> kÏ† mÎ› core
(reflect 'L t) (reflect 'R t)
(reconstitute t)                        ; -> Ï(t) = [L]t âŠ•B [R]t
(register-observable i term)
(value g i) (value G i j) (value beta-Î¼ i) (value beta-Î¸ i) (value a) (value c)

;; --- moduli & flows (four core + two aux) ---
(set-moduli! #:Î¼L Î¼L #:Î¸L Î¸L #:Î¼R Î¼R #:Î¸R Î¸R #:z z #:barz barz)
(normal-form-4mod t)                    ; NF_{Î¼L,Î¸L,Î¼R,Î¸R}

;; --- guarded negation (local NAND) ---
(set-guard! g)                          ; choose guard g âˆˆ L
(gn-not x)                              ; Â¬^g(x)
(gn-nand x y)                           ; NAND

;; --- PSDM ---
(define-psdm! #:L-map DL #:B-map DB #:R-map DR
              #:totality halts? #:valuation w #:minkowski? #f)
(psdm-apply t) (psdm-defined? t)

;; --- Feynman faÃ§ade ---
(histories J) (history-weight H) (sum-over-histories J)
(schwinger-dyson i F)

;; --- domain ports ---
(port-boolean) (port-lambda) (port-infoflow) (port-qft)
```

---

## 9) Unit tests (CLASS, a selection)

```csh
# -- Moduli setup (four core + two aux) --
logic eval "(set-moduli! #:Î¼L 0 #:Î¸L 0 #:Î¼R 0 #:Î¸R 0 #:z z0 #:barz zb0)"

# Boundary-aware NF acts header-only, per side (integer scale)
logic eval "(define t '(âŠ—B (ad 0 (gen4 a0 a1 a2 a3)) (ad 1 (gen4 a0 a1 a2 a3))))"
logic eval "(normal-form-4mod t)"

# Guarded NAND yields XOR via 3 NAND gates (local universality smoke)
logic eval "(set-guard! 1_L)"
logic eval "(define X '(Î¹_L 1_L)) (define Y '(Î¹_L 1_L))"
logic eval "(gn-nand X (gn-nand X Y))"   # etc. â€” check truth table by a PSDM boolean port

# PSDM partiality: undefined on non-halting
logic eval "(define-psdm! #:L-map 'bool #:B-map 'circuits #:R-map 'bool #:totality 'halts? #:valuation 'degree)"
logic eval "(psdm-defined? '(encode-nonhalting))"       # -> #f

# Feynman = cumulant expansion
logic eval "(sum-over-histories '(J0))"
logic eval "(value g 0)"

# Truth theorem checks
; (1) bulk = two boundaries (already in core tests)
; (2) Î” commutes with NF (scheme stability)
logic eval "(check-umbral-renormalisation?)"             # should pass on chart
; (3) Churchâ†”Turing inside
logic eval "(church-turing-agree? 'progP 'inputX #:truncate 6)"  # -> #t
; (4) EOR
logic eval "(eor-health? #:header #t #:core #t #:braid #t #:symbols #t)"      # -> #t
; (5) logic-Î¶ critical-line (internal)
logic eval "(logic-grh-gate? #:fisher-self-adjoint? #t #:truncate 8)"         # -> #t

# Non-normative: Feynman == Green's sum to truncation
logic eval "(equal? 'L '(sum-over-histories J :N 4) '(observer-L (greens-sum K 4)))"  # -> #t

# Auxiliary-modulated braids: adáµ¢ preserves headers, Ëœadáµ¢ carries weight
logic eval "(let ((k mz mbar core (dec_{z\\bar{z}} (ad 0 t))))
              (equal? '(k mz mbar core) (dec_{z\\bar{z}} t)))"        # -> #t  (v2)
logic eval "(history-weight (list '(Ëœad 0)))"                         # nontrivial central monomial

# Choose a simple split: left scaleâ†’z, right scaleâ†’barz
logic eval "(set-R-data! 'identity)"
# Make a toy term and compute one modulated step
logic eval "(define t '(âŠ—B (Ï†^ 1) (âŠ—B (Î›^ 2) coreX)))"
logic eval "(define H (list '(Ëœad 0)))"
# ad leaves headers, weight comes from ð“œ:
logic eval "(equal? 'B '(history-weight H)
                  '(âŠ—B (Ï†^ (+ (/ (- (fÎ¸L 1) 1) 2) (/ (- (fÎ¸R 1) 1) 2)))
                        (âŠ—B (z^ (- (gÎ¼L 2) 2)) (barz^ (- (gÎ¼R 2) 2)))))"

# Contracting step smoke test (negative scale)
logic eval "(well-typed? 'B '(Î›^{-1}))"                          ; -> #t (v2 units)
logic eval "(define Hc (list '(ad 0 ; (Ï†^ 0) (z^ -1) (barz^ 0))))" ; contracting in z
logic eval "(history-weight Hc)"                                  ; central monomial with negative exponent
```

---

## 10) Minimality & non-collapse

- **Minimal:** only the four core moduli & two auxiliaries are added to v10 Core; guarded negation lives in **locals** only; PSDM carries irreversibility; Feynman is a definitional faÃ§ade.  
- **Nonâ€‘collapse:** each domain port is a map, not an identification; **EOR** prevents aliasing; global logic remains constructive and trialityâ€‘based; Boolean/QFT/infoâ€‘flow semantics live **in the ports**, not in the core.

*End CLASS.*
