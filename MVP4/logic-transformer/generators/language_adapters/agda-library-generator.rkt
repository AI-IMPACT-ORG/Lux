#lang typed/racket

(require racket/list
         racket/string
         racket/file
         "../api-surface/library-api.rkt"
         "common.rkt")

(provide generate-agda-library)

(struct GenerationConfig ([moduli : (Listof Natural)]) #:transparent)

(define default-config (GenerationConfig default-moduli))

(: write-line (-> Output-Port String Void))
(define (write-line out line)
  (fprintf out "~a~n" line))

(: agda-register (-> Symbol String))
(define (agda-register sym)
  (string-append (snake->pascal sym) "Reg"))

(: agda-edge (-> Symbol String))
(define (agda-edge sym)
  (snake->pascal sym))

(: agda-list (-> (Listof String) String))
(define (agda-list items)
  (cond
    [(null? items) "[]"]
    [(null? (cdr items)) (string-append (car items) " ∷ []")]
    [else (string-append (car items) " ∷ " (agda-list (cdr items)))]))

(: agda-src-or-dst (-> (Listof Symbol) String))
(define (agda-src-or-dst symbols)
  (agda-list (map agda-register symbols)))

(: render-m3-content (-> SampleSpec GenerationConfig String))
(define (render-m3-content sample config)
  (define ports (SampleSpec-ports sample))
  (define edges (SampleSpec-edges sample))
  (define moduli (GenerationConfig-moduli config))
  (: moduli-identifiers (Listof (Pairof String Natural)))
  (define moduli-identifiers
    (list (cons "μ₁" 0) (cons "μ₂" 1) (cons "μ₃" 2) (cons "μ₄" 3)
          (cons "μ₁★" 4) (cons "μ₂★" 5) (cons "μ₃★" 6) (cons "μ₄★" 7)
          (cons "λ" 8) (cons "λ★" 9)))
  (define moduli-lines
    (for/list : (Listof String) ([entry (in-list moduli-identifiers)])
      (let ([label (car entry)]
            [idx (cdr entry)])
        (format "-- ~a = ~a" label (list-ref moduli idx)))))
  (define register-lemma-name (format "register-count≡~a" (length ports)))
  (define edge-lemma-name (format "edge-count≡~a" (length edges)))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "module Generated_Library.BootstrapPaper.Foundations.M3 where")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "-- Auto-generated from lt-core host bundle")
      (for ([line moduli-lines])
        (write-line (current-output-port) line))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "open import Data.Nat using (ℕ; zero; suc; _*_)")
      (write-line (current-output-port) "open import Data.List.Base using (List; []; _∷_; length)")
      (write-line (current-output-port) "open import Relation.Binary.PropositionalEquality using (_≡_; refl)")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "data Register : Set where")
      (for ([reg ports])
        (write-line (current-output-port)
                    (format "  ~a : Register" (agda-register reg))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "data EdgeKind : Set where")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "  ~a : EdgeKind" (agda-edge (EdgeSpec-name edge)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record Arity : Set where")
      (write-line (current-output-port) "  field")
      (write-line (current-output-port) "    inputs  : ℕ")
      (write-line (current-output-port) "    outputs : ℕ")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "arityOf : EdgeKind → Arity")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "arityOf ~a = record { inputs = ~a ; outputs = ~a }"
                            (agda-edge (EdgeSpec-name edge))
                            (EdgeSpec-inputs edge)
                            (EdgeSpec-outputs edge))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "srcOf : EdgeKind → List Register")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "srcOf ~a = ~a"
                            (agda-edge (EdgeSpec-name edge))
                            (agda-src-or-dst (EdgeSpec-src edge)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "dstOf : EdgeKind → List Register")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "dstOf ~a = ~a"
                            (agda-edge (EdgeSpec-name edge))
                            (agda-src-or-dst (EdgeSpec-dst edge)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record TypeGraph : Set where")
      (write-line (current-output-port) "  field")
      (write-line (current-output-port) "    registers : List Register")
      (write-line (current-output-port) "    edgeKinds : List EdgeKind")
      (write-line (current-output-port) "    arityMap  : EdgeKind → Arity")
      (write-line (current-output-port) "    srcMap    : EdgeKind → List Register")
      (write-line (current-output-port) "    dstMap    : EdgeKind → List Register")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "sampleGraph : TypeGraph")
      (write-line (current-output-port)
                  (format "sampleGraph = record { registers = ~a" (agda-list (map agda-register ports))))
      (write-line (current-output-port)
                  (format ", edgeKinds = ~a" (agda-list (map agda-edge (map EdgeSpec-name edges)))))
      (write-line (current-output-port) ", arityMap  = arityOf")
      (write-line (current-output-port) ", srcMap    = srcOf")
      (write-line (current-output-port) ", dstMap    = dstOf")
      (write-line (current-output-port) "}")
      (write-line (current-output-port) "")
      (write-line (current-output-port)
                  (format "~a : length (TypeGraph.registers sampleGraph) ≡ ~a"
                          register-lemma-name
                          (length ports)))
      (write-line (current-output-port)
                  (format "~a = refl" register-lemma-name))
      (write-line (current-output-port) "")
      (write-line (current-output-port)
                  (format "~a : length (TypeGraph.edgeKinds sampleGraph) ≡ ~a"
                          edge-lemma-name
                          (length edges)))
      (write-line (current-output-port)
                  (format "~a = refl" edge-lemma-name))
      (write-line (current-output-port) "")
      (for ([edge edges])
        (define lemma-name (format "src-length-~a" (snake->camel (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "~a : length (srcOf ~a) ≡ ~a"
                            lemma-name
                            (agda-edge (EdgeSpec-name edge))
                            (length (EdgeSpec-src edge))))
        (write-line (current-output-port)
                    (format "~a = refl" lemma-name)))
      (write-line (current-output-port) "")
      )))

(: render-metalogic-bundle (-> SampleSpec GenerationConfig String))
(define (render-metalogic-bundle sample config)
  (define sigma6-edge (find-edge-spec (SampleSpec-edges sample) 'sigma6))
  (define sigma6-base-lemma (format "renormalise-base-~a" (snake->camel (EdgeSpec-name sigma6-edge))))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "module Generated_Library.BootstrapPaper.Proofs.Metalogic where")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Foundations.M3")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Operators.RG")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Tests.Core")
      (write-line (current-output-port) "open import Relation.Binary.PropositionalEquality using (_≡_; refl)")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record MetalogicBundle : Set where")
      (write-line (current-output-port) "  field")
      (write-line (current-output-port) "    noether-identity : renormalise 1 Sigma6 ≡ arityOf Sigma6")
      (write-line (current-output-port) "    ward-identity    : renormalise 2 Sigma6 ≡ record { inputs = inputs (arityOf Sigma6) ; outputs = outputs (arityOf Sigma6) * 2 }")
      (write-line (current-output-port) "    gamma-gamma      : scaleArity 1 (arityOf Sigma6) ≡ arityOf Sigma6")
      (write-line (current-output-port) "    renormalisable   : renormalise 2 Sigma6 ≡ scaleArity 2 (arityOf Sigma6)")
      (write-line (current-output-port) "    rice-generalised : renormalise 1 Sigma6 ≡ renormalise 1 Sigma6")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "bundle : MetalogicBundle")
      (write-line (current-output-port) "bundle = record")
      (write-line (current-output-port)
                  (format "  { noether-identity = ~a" sigma6-base-lemma))
      (write-line (current-output-port) "  ; ward-identity = sigma6-renormalise-twice")
      (write-line (current-output-port) "  ; gamma-gamma = scaleArity-identity (arityOf Sigma6)")
      (write-line (current-output-port) "  ; renormalisable = refl")
      (write-line (current-output-port) "  ; rice-generalised = refl")
      (write-line (current-output-port) "  }"))))

(: render-rg-content (-> SampleSpec String))
(define (render-rg-content sample)
  (define edges (SampleSpec-edges sample))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "module Generated_Library.BootstrapPaper.Operators.RG where")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Foundations.M3")
      (write-line (current-output-port) "open import Data.Nat using (ℕ; _*_)")
      (write-line (current-output-port) "open import Relation.Binary.PropositionalEquality using (_≡_; refl)")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "scaleArity : ℕ → Arity → Arity")
      (write-line (current-output-port) "scaleArity scale a = record { inputs = inputs a ; outputs = outputs a * scale }")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "renormalise : ℕ → EdgeKind → Arity")
      (write-line (current-output-port) "renormalise scale k = scaleArity scale (arityOf k)")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "scaleArity-identity : (a : Arity) → scaleArity 1 a ≡ a")
      (write-line (current-output-port) "scaleArity-identity a = refl")
      (write-line (current-output-port) "")
      (for ([edge edges])
        (define lemma-name (format "renormalise-base-~a" (snake->camel (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "~a : renormalise 1 ~a ≡ arityOf ~a"
                            lemma-name
                            (agda-edge (EdgeSpec-name edge))
                            (agda-edge (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "~a = refl" lemma-name)))
      )))

(: render-tests-content (-> SampleSpec String))
(define (render-tests-content sample)
  (define edges (SampleSpec-edges sample))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "module Generated_Library.BootstrapPaper.Tests.Core where")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Foundations.M3")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Operators.RG")
      (write-line (current-output-port) "open import Relation.Binary.PropositionalEquality using (_≡_; refl)")
      (write-line (current-output-port) "")
      (for ([edge edges])
        (define lemma-name (format "src-pattern-~a" (snake->camel (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "~a : srcOf ~a ≡ ~a"
                            lemma-name
                            (agda-edge (EdgeSpec-name edge))
                            (agda-src-or-dst (EdgeSpec-src edge))))
        (write-line (current-output-port)
                    (format "~a = refl" lemma-name)))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "sigma6-renormalise-twice : renormalise 2 Sigma6 ≡ record { inputs = inputs (arityOf Sigma6) ; outputs = outputs (arityOf Sigma6) * 2 }")
      (write-line (current-output-port) "sigma6-renormalise-twice = refl")
      )))

(: render-proof-bundle (-> SampleSpec GenerationConfig String))
(define (render-proof-bundle sample config)
  (define ports (SampleSpec-ports sample))
  (define edges (SampleSpec-edges sample))
  (define sigma6-edge (find-edge-spec edges 'sigma6))
  (define register-lemma-name (format "register-count≡~a" (length ports)))
  (define edge-lemma-name (format "edge-count≡~a" (length edges)))
  (define sigma6-base-lemma (format "renormalise-base-~a" (snake->camel (EdgeSpec-name sigma6-edge))))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "module Generated_Library.BootstrapPaper.Proofs.MultiLogic where")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Foundations.M3")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Operators.RG")
      (write-line (current-output-port) "open import Generated_Library.BootstrapPaper.Tests.Core")
      (write-line (current-output-port) "open import Relation.Binary.PropositionalEquality using (_≡_; refl)")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record MultiLogicBundle : Set where")
      (write-line (current-output-port) "  field")
      (write-line (current-output-port) "    graph          : TypeGraph")
      (write-line (current-output-port)
                  (format "    registers-ok  : length (TypeGraph.registers graph) ≡ ~a" (length ports)))
      (write-line (current-output-port)
                  (format "    edges-ok      : length (TypeGraph.edgeKinds graph) ≡ ~a" (length edges)))
      (write-line (current-output-port) "    sigma6-base   : renormalise 1 Sigma6 ≡ arityOf Sigma6")
      (write-line (current-output-port)
                  "    sigma6-double : renormalise 2 Sigma6 ≡ record { inputs = inputs (arityOf Sigma6) ; outputs = outputs (arityOf Sigma6) * 2 }")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "bundle : MultiLogicBundle")
      (write-line (current-output-port) "bundle = record")
      (write-line (current-output-port) "  { graph = sampleGraph")
      (write-line (current-output-port)
                  (format "  ; registers-ok = ~a" register-lemma-name))
      (write-line (current-output-port)
                  (format "  ; edges-ok = ~a" edge-lemma-name))
      (write-line (current-output-port)
                  (format "  ; sigma6-base = ~a" sigma6-base-lemma))
      (write-line (current-output-port) "  ; sigma6-double = sigma6-renormalise-twice")
      (write-line (current-output-port) "  }"))))

(: write-module (-> String String Void))
(define (write-module path content)
  (call-with-output-file path
    (lambda ([out : Output-Port])
      (display content out))
    #:exists 'replace))

(: generate-agda-library (-> (U GenerationConfig #f) Void))
(define (generate-agda-library config)
  (define cfg (or config default-config))
  (define output-dir "../../formal/agda/Generated_Library/BootstrapPaper")
  (unless (directory-exists? output-dir)
    (make-directory* output-dir))
  (for ([sub '("Foundations" "Operators" "Tests" "Proofs")])
    (make-directory* (string-append output-dir "/" sub)))
  (define sample sample-spec)
  (write-module (string-append output-dir "/Foundations/M3.agda")
                (render-m3-content sample cfg))
  (write-module (string-append output-dir "/Operators/RG.agda")
                (render-rg-content sample))
  (write-module (string-append output-dir "/Tests/Core.agda")
                (render-tests-content sample))
  (write-module (string-append output-dir "/Proofs/MultiLogic.agda")
                (render-proof-bundle sample cfg))
  (write-module (string-append output-dir "/Proofs/Metalogic.agda")
                (render-metalogic-bundle sample cfg))
  (printf "Generated Agda library with ~a registers and ~a edges.~n"
          (length (SampleSpec-ports sample))
          (length (SampleSpec-edges sample))))

;; Execute when invoked directly
(generate-agda-library #f)
