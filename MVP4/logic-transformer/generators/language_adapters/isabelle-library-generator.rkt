#lang typed/racket

(require racket/list
         racket/string
         racket/file
         "../api-surface/library-api.rkt"
         "common.rkt")

(provide generate-isabelle-library)

(struct GenerationConfig ([moduli : (Listof Natural)]) #:transparent)

(define default-config (GenerationConfig default-moduli))

(: write-line (-> Output-Port String Void))
(define (write-line out line)
  (fprintf out "~a~n" line))

(: isa-register (-> Symbol String))
(define (isa-register sym)
  (string-append (snake->pascal sym) "Reg"))

(: isa-edge (-> Symbol String))
(define (isa-edge sym)
  (snake->pascal sym))

(: isa-list (-> (Listof String) String))
(define (isa-list items)
  (if (null? items)
      "[]"
      (string-append "[" (string-join items ", ") "]")))

(: isa-src-or-dst (-> (Listof Symbol) String))
(define (isa-src-or-dst symbols)
  (isa-list (map isa-register symbols)))

(: render-m3-content (-> SampleSpec GenerationConfig String))
(define (render-m3-content sample config)
  (define ports (SampleSpec-ports sample))
  (define edges (SampleSpec-edges sample))
  (define moduli (GenerationConfig-moduli config))
  (: moduli-identifiers (Listof (Pairof String Natural)))
  (define moduli-identifiers
    (list (cons "μ₁" 0) (cons "μ₂" 1) (cons "μ₃" 2) (cons "μ₄" 3)
          (cons "μ₁★" 4) (cons "μ₂★" 5) (cons "μ₃★" 6) (cons "μ₄★" 7)
          (cons "λ" 8) (cons "λ★" 9)))
  (define moduli-lines
    (for/list : (Listof String) ([entry (in-list moduli-identifiers)])
      (let ([label (car entry)]
            [idx (cdr entry)])
        (format "(* ~a = ~a *)" label (list-ref moduli idx)))))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "theory M3")
      (write-line (current-output-port) "  imports Main")
      (write-line (current-output-port) "begin")
      (write-line (current-output-port) "")
      (for ([line moduli-lines]) (write-line (current-output-port) line))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "datatype Register =")
      (for ([reg ports])
        (write-line (current-output-port)
                    (format "    ~a" (isa-register reg))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "datatype EdgeKind =")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "    ~a" (isa-edge (EdgeSpec-name edge)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record Arity =")
      (write-line (current-output-port) "  inputs  :: nat")
      (write-line (current-output-port) "  outputs :: nat")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition registers :: \"Register list\" where")
      (write-line (current-output-port)
                  (format "  \"registers = ~a\"" (isa-list (map isa-register ports))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition edgeKinds :: \"EdgeKind list\" where")
      (write-line (current-output-port)
                  (format "  \"edgeKinds = ~a\"" (isa-list (map isa-edge (map EdgeSpec-name edges)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "fun arity_of :: \"EdgeKind ⇒ Arity\" where")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "  \"arity_of ~a = ⦇ inputs = ~a, outputs = ~a ⦈\""
                            (isa-edge (EdgeSpec-name edge))
                            (EdgeSpec-inputs edge)
                            (EdgeSpec-outputs edge))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "fun src_of :: \"EdgeKind ⇒ Register list\" where")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "  \"src_of ~a = ~a\""
                            (isa-edge (EdgeSpec-name edge))
                            (isa-src-or-dst (EdgeSpec-src edge)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "fun dst_of :: \"EdgeKind ⇒ Register list\" where")
      (for ([edge edges])
        (write-line (current-output-port)
                    (format "  \"dst_of ~a = ~a\""
                            (isa-edge (EdgeSpec-name edge))
                            (isa-src-or-dst (EdgeSpec-dst edge)))))
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record TypeGraph =")
      (write-line (current-output-port) "  tg_registers :: \"Register list\"")
      (write-line (current-output-port) "  tg_edgeKinds :: \"EdgeKind list\"")
      (write-line (current-output-port) "  tg_arityMap  :: \"EdgeKind ⇒ Arity\"")
      (write-line (current-output-port) "  tg_srcMap    :: \"EdgeKind ⇒ Register list\"")
      (write-line (current-output-port) "  tg_dstMap    :: \"EdgeKind ⇒ Register list\"")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition sample_graph :: TypeGraph where")
      (write-line (current-output-port) "  \"sample_graph = ⦇ tg_registers = registers, tg_edgeKinds = edgeKinds,")
      (write-line (current-output-port) "     tg_arityMap = arity_of, tg_srcMap = src_of, tg_dstMap = dst_of ⦈\"")
      (write-line (current-output-port) "")
      (write-line (current-output-port)
                  (format "lemma registers_length : length (tg_registers sample_graph) = ~a" (length ports)))
      (write-line (current-output-port) "  by (simp add: sample_graph_def registers_def)")
      (write-line (current-output-port) "")
      (write-line (current-output-port)
                  (format "lemma edges_length : length (tg_edgeKinds sample_graph) = ~a" (length edges)))
      (write-line (current-output-port) "  by (simp add: sample_graph_def edgeKinds_def)")
      (write-line (current-output-port) "")
      (for ([edge edges])
        (define lemma-name (format "src_length_~a" (snake->camel (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "lemma ~a : length (src_of ~a) = ~a"
                            lemma-name
                            (isa-edge (EdgeSpec-name edge))
                            (length (EdgeSpec-src edge))))
        (write-line (current-output-port) "  by simp")
        (write-line (current-output-port) ""))
      (write-line (current-output-port) "end")
      )))

(: render-rg-content (-> SampleSpec String))
(define (render-rg-content sample)
  (define edges (SampleSpec-edges sample))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "theory RG")
      (write-line (current-output-port) "  imports M3")
      (write-line (current-output-port) "begin")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition scale_arity :: \"nat ⇒ Arity ⇒ Arity\" where")
      (write-line (current-output-port) "  \"scale_arity s a = ⦇ inputs = inputs a, outputs = outputs a * s ⦈\"")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition renormalise :: \"nat ⇒ EdgeKind ⇒ Arity\" where")
      (write-line (current-output-port) "  \"renormalise s k = scale_arity s (arity_of k)\"")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "lemma scale_arity_identity : scale_arity 1 a = a")
      (write-line (current-output-port) "  by (cases a) (simp add: scale_arity_def)")
      (write-line (current-output-port) "")
      (for ([edge edges])
        (define lemma-name (format "renormalise_base_~a" (snake->camel (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "lemma ~a : renormalise 1 ~a = arity_of ~a"
                            lemma-name
                            (isa-edge (EdgeSpec-name edge))
                            (isa-edge (EdgeSpec-name edge))))
        (write-line (current-output-port) "  by (simp add: renormalise_def scale_arity_def)")
        (write-line (current-output-port) ""))
      (write-line (current-output-port) "end")
      )))

(: render-tests-content (-> SampleSpec String))
(define (render-tests-content sample)
  (define edges (SampleSpec-edges sample))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "theory Tests")
      (write-line (current-output-port) "  imports M3 RG")
      (write-line (current-output-port) "begin")
      (write-line (current-output-port) "")
      (for ([edge edges])
        (define lemma-name (format "src_pattern_~a" (snake->camel (EdgeSpec-name edge))))
        (write-line (current-output-port)
                    (format "lemma ~a : src_of ~a = ~a"
                            lemma-name
                            (isa-edge (EdgeSpec-name edge))
                            (isa-src-or-dst (EdgeSpec-src edge))))
        (write-line (current-output-port) "  by simp")
        (write-line (current-output-port) ""))
      (write-line (current-output-port)
                  "lemma sigma6_renormalise_twice : renormalise 2 Sigma6 = ⦇ inputs = inputs (arity_of Sigma6), outputs = outputs (arity_of Sigma6) * 2 ⦈")
      (write-line (current-output-port) "  by (simp add: renormalise_def scale_arity_def)")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "end")
      )))

(: render-proof-bundle (-> SampleSpec String))
(define (render-proof-bundle sample)
  (define ports (SampleSpec-ports sample))
  (define edges (SampleSpec-edges sample))
  (define sigma6-edge (find-edge-spec edges 'sigma6))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "theory Bundle")
      (write-line (current-output-port) "  imports Tests")
      (write-line (current-output-port) "begin")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record MultiLogicBundle =")
      (write-line (current-output-port) "  ml_graph :: TypeGraph")
      (write-line (current-output-port)
                  (format "  ml_registers :: length (tg_registers ml_graph) = ~a" (length ports)))
      (write-line (current-output-port)
                  (format "  ml_edges :: length (tg_edgeKinds ml_graph) = ~a" (length edges)))
      (write-line (current-output-port)
                  "  ml_sigma6_base :: renormalise 1 Sigma6 = arity_of Sigma6")
      (write-line (current-output-port)
                  "  ml_sigma6_double :: renormalise 2 Sigma6 = ⦇ inputs = inputs (arity_of Sigma6), outputs = outputs (arity_of Sigma6) * 2 ⦈")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition bundle :: MultiLogicBundle where")
      (write-line (current-output-port) "  \"bundle = ⦇ ml_graph = sample_graph,")
      (write-line (current-output-port) "     ml_registers = registers_length,")
      (write-line (current-output-port) "     ml_edges = edges_length,")
      (write-line (current-output-port)
                  (format "     ml_sigma6_base = renormalise_base_~a," (snake->camel (EdgeSpec-name sigma6-edge))))
      (write-line (current-output-port) "     ml_sigma6_double = sigma6_renormalise_twice ⦈\"")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "end")
      )))

(: render-metalogic-bundle (-> SampleSpec String))
(define (render-metalogic-bundle sample)
  (define sigma6-edge (find-edge-spec (SampleSpec-edges sample) 'sigma6))
  (with-output-to-string
    (lambda ()
      (write-line (current-output-port) "theory Metalogic")
      (write-line (current-output-port) "  imports RG")
      (write-line (current-output-port) "begin")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "record MetalogicBundle =")
      (write-line (current-output-port) "  ml_noether :: renormalise 1 Sigma6 = arity_of Sigma6")
      (write-line (current-output-port) "  ml_ward :: renormalise 2 Sigma6 = ⦇ inputs = inputs (arity_of Sigma6), outputs = outputs (arity_of Sigma6) * 2 ⦈")
      (write-line (current-output-port) "  ml_gamma_gamma :: scale_arity 1 (arity_of Sigma6) = arity_of Sigma6")
      (write-line (current-output-port) "  ml_renormalisable :: renormalise 2 Sigma6 = scale_arity 2 (arity_of Sigma6)")
      (write-line (current-output-port) "  ml_rice :: renormalise 1 Sigma6 = renormalise 1 Sigma6")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "definition metalogic_bundle :: MetalogicBundle where")
      (write-line (current-output-port)
                  (format "  \"metalogic_bundle = ⦇ ml_noether = renormalise_base_~a," (snake->camel (EdgeSpec-name sigma6-edge))))
      (write-line (current-output-port) "     ml_ward = sigma6_renormalise_twice,")
      (write-line (current-output-port) "     ml_gamma_gamma = scale_arity_identity (arity_of Sigma6),")
      (write-line (current-output-port) "     ml_renormalisable = refl,")
      (write-line (current-output-port) "     ml_rice = refl ⦈\"")
      (write-line (current-output-port) "")
      (write-line (current-output-port) "end")
      )))

(: write-module (-> String String Void))
(define (write-module path content)
  (call-with-output-file path
    (lambda ([out : Output-Port])
      (display content out))
    #:exists 'replace))

(: generate-isabelle-library (-> (U GenerationConfig #f) Void))
(define (generate-isabelle-library config)
  (define cfg (or config default-config))
  (define output-dir "../../formal/isabelle/Generated_Library")
  (make-directory* output-dir)
  (define sample sample-spec)
  (write-module (string-append output-dir "/M3.thy")
                (render-m3-content sample cfg))
  (write-module (string-append output-dir "/RG.thy")
                (render-rg-content sample))
  (write-module (string-append output-dir "/Tests.thy")
                (render-tests-content sample))
  (write-module (string-append output-dir "/Bundle.thy")
                (render-proof-bundle sample))
  (write-module (string-append output-dir "/Metalogic.thy")
                (render-metalogic-bundle sample))
  (printf "Generated Isabelle library with ~a registers and ~a edges.~n"
          (length (SampleSpec-ports sample))
          (length (SampleSpec-edges sample))))

(generate-isabelle-library #f)
