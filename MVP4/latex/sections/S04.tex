\section{renormalisation: From Raw to Refined}
\label{sec:renormalisation}

§6 uses §5's $\beta$/$\gamma$ functions to remove divergences and obtain finite correlators.

\textbf{Terminology:} We use "normalisation" for the idempotent logical operator $N$ and "renormalisation" only for RG flow.

Having established the RG flow machinery in Section~\ref{sec:rg-flow}, we now develop the complete renormalisation procedure that handles computational divergences and ensures self-consistency. This implements the three-level Green's functions hierarchy (bare, dressed, renormalized) introduced in Section~\ref{sec:computation-paradigms}. In the physics domain, this corresponds to extracting finite S-matrix elements from divergent Feynman diagrams.

\subsection{Scale and Phase Scalars}

The scale scalars $z, \bar{z}$ encode presentation gauges that are always factored out:

\begin{definition}[Scale and Phase Gauges]
\label{def:scale-phase-gauges}
The scale scalars encode two fundamental gauges:
\begin{align}
\text{Scale gauge: } &\text{overall scale} = z \otimes_B \bar{z} \\
\text{Phase gauge: } &\text{phase exchange} = \varphi \leftrightarrow \bar{\varphi}
\end{align}
These gauges are always factored out in all observational equalities, with comparisons computed modulo the active quotient mask $qmask \subseteq \{\text{phase}, \text{scale}\}$ (default $\{\text{phase}\}$). See the canonical domain ledger Table~\ref{tab:universal-domain-translation} for cross-domain readings.
\end{definition}

\begin{theorem}[Eliminability of Scale Scalars]
\label{thm:eliminability-auxiliaries}
The scale scalars $z, \bar{z}$ are eliminable. \textbf{Proved in Theorem~\ref{thm:conservativity}.} Adding $z, \bar{z}$ is a conservative definitional extension that provides presentation conveniences without affecting logical content (see Table~\ref{tab:universal-domain-translation} for domain-specific interpretations).
\end{theorem}

\subsection{Bare vs Renormalized Correlators}

In the context of our computational generating function framework, we distinguish between bare and renormalized correlators through their relationship to the RG flow and computational semantics. This distinction is crucial for understanding how computational processes can be made well-defined within the L/B/R structure (see Table~\ref{tab:universal-domain-translation} for domain-specific interpretations).

\begin{definition}[Bare Correlators]
\label{def:bare-correlators}
The bare correlators correspond to the bare Green's function $\mathcal{G}_{\text{bare}}$ from Definition~\ref{def:greens-functions-hierarchy}:
\[
\mathcal{G}_{\text{bare}}(z, \bar{z}; \vec{q}^{(0)}, \Lambda) = \sum_{n,m=0}^{\infty} \frac{z^n \bar{z}^m}{n! m!} \cdot \mathcal{Z}_{n,m}(\vec{q}^{(0)}) \cdot \Lambda^{-(n+m)}
\]
where $\vec{q}^{(0)}$ are the bare coupling parameters and $\mathcal{Z}_{n,m}(\vec{q}^{(0)}) = \langle n,m|\hat{W}(\vec{q}^{(0)})|0\rangle$ are the bare matrix elements without any RG flow corrections.
\end{definition}

\begin{definition}[Renormalized Correlators]
\label{def:renormalized-greens}
The renormalized correlators are obtained by applying the RG map $\mathcal{R}_b$ to the bare functions:
\[
\mathsf{Gen4}^{\text{ren}}(z, \bar{z}; \vec{q}, \Lambda) = \lim_{b \to \infty} (\mathcal{R}_b \mathsf{Gen4}^{\text{bare}})(z, \bar{z}; \vec{q}, \Lambda)
\]
where the RG map acts on the weights as:
\[
(\mathcal{R}_b\mathcal{Z})_{n,m} = b^{-\Delta(n,m)}\,\mathcal{Z}_{\lfloor n/b\rfloor,\lfloor m/b\rfloor}
\]
We fix a bi-degree scaling $\Delta:\mathbb{N}^2\to\mathbb{R}$; the coarse map is $(\mathcal{R}_b\mathcal{Z})_{n,m}=b^{-\Delta(n,m)}\mathcal{Z}_{n,m}$.
\end{definition}

The bare correlators represent the raw computational weights before any renormalisation procedure is applied, while the renormalized correlators represent the finite, well-defined computational weights after removing divergences.

\subsection{Complete renormalisation Procedure}

The "bare→RG→renormalised→remove regulator" pipeline:
\begin{itemize}
\item \textbf{Bare}: Start with raw correlators $\mathcal{Z}_{n,m}(\vec{q}^{(0)})$ before any renormalisation
\item \textbf{RG}: Apply RG map $\mathcal{R}_b$ to evolve from scale $\Lambda$ to scale $b\Lambda$  
\item \textbf{Renormalised}: Obtain finite correlators $\mathcal{Z}_{n,m}^{\text{ren}}(\vec{q})$ after removing divergences
\item \textbf{Remove regulator}: Take limit $b \to \infty$ to obtain final renormalized correlators
\end{itemize}

\subsection{Key Differences and RG Fixed Points}

\begin{proposition}[Renormalised vs Unrenormalised Correlators]
\label{prop:renormalised-difference}
The key differences between renormalised and unrenormalised correlators are:
\begin{enumerate}
\item Finite vs Divergent: Renormalised correlators are finite, while unrenormalised ones may diverge
\item RG Flow Behavior: Renormalised correlators exhibit converging RG flow, while unrenormalised ones may diverge or oscillate
\item Computational Semantics: Renormalised correlators correspond to reversible computations, while unrenormalised ones may correspond to irreversible or undecidable computations
\item Information Preservation: Renormalised correlators preserve information, while unrenormalised ones may destroy information
\end{enumerate}

\textbf{Physics interpretation:} Renormalised correlators correspond to physical observables (cross-sections), while unrenormalised ones contain UV divergences that must be subtracted.
\end{proposition}

\begin{definition}[RG Fixed Points]
\label{def:rg-fixed-points-renorm}
A renormalised correlator $\mathcal{G}_{\text{ren}}$ is at an RG fixed point if:
\[
\mathcal{R}_b \mathcal{G}_{\text{ren}} = \mathcal{G}_{\text{ren}}
\]
for all $b > 1$. Fixed points correspond to scale-invariant computational processes.
\end{definition}

\begin{definition}[renormalisation map]
\label{def:R-map}
$\mathcal{R}_\Lambda: \mathcal{G} \mapsto \mathcal{G}_{\text{ren}}$ with
\[
\mathcal{Z}_{n,m}^{\text{ren}}(\vec{q}) = \mathcal{Z}_{n,m}(\vec{q}) - C_{n,m}(\vec{q};\Lambda),
\]
where $C_{n,m}$ removes contributions from substructures of size $<\frac{1}{\Lambda}$.
\end{definition}

\begin{proposition}[Scheme independence of observables]
\label{prop:scheme-independence}
If $C_{n,m}$ differ by a finite reparametrization $\vec{q} \mapsto \vec{q}'$, then $\mathcal{O}(\Lambda)$ is invariant.
\end{proposition}

\begin{example}[Before/after renormalisation]
Consider $G$ with one nonzero $\mathcal{Z}_{1,0} = 1$. After renormalisation:
\[
\mathcal{Z}_{1,0}^{\text{ren}} = 1 - C_{1,0}(\Lambda) = 1 - \frac{1}{\Lambda} = \frac{\Lambda-1}{\Lambda}
\]
The counterterm $C_{1,0}(\Lambda) = \frac{1}{\Lambda}$ removes the divergent contribution from substructures smaller than $\frac{1}{\Lambda}$.
\end{example}

The renormalisation procedure applies uniformly across all computational paradigms, with each paradigm implementing the same underlying principle through different mathematical structures. Traditional computational models (Turing machines, lambda calculus, path integrals) represent the renormalized versions of their raw, bare counterparts.

In the S‑matrix port, renormalised correlators determine $S(\Lambda)$ via LSZ‑type limits at the boundaries; the PSDM makes the optical identity a statement about renormalised $\sigma_{\alpha;N}$, not total unitarity, in line with partial semantics.

Finite reparametrizations of $\vec{q}$ and $\tau$ encode normalisation choices from §1; different schemes correspond to transporting those choices along the flow.

\subsection{renormalisation Group Equations}

\begin{definition}[renormalisation Group Equations]
\label{def:rg-equations-renorm}
The renormalisation group equations for the logic transformer are:
\begin{align}
\Lambda \frac{d}{d\Lambda} \llbracket \mathsf{Gen4}(\phi,\bar{\phi};q_1,q_2,q_3;\Lambda)\rrbracket_{\text{ren}} &= 0\\
\Lambda \frac{d}{d\Lambda} q_i &= \beta_i(q_1,q_2,q_3) \quad \text{for } i = 1,2,3
\end{align}
\end{definition}

For our HEP-TH audience, this should feel natural: just as RG equations in QFT ensure that physical observables are independent of the renormalisation scale, our computational RG equations ensure that computational observables are independent of the computational scale.

\subsection{Summary and Outlook}

This section established the complete renormalisation procedure:

\begin{enumerate}
\item Distinction between bare and renormalized correlators is fundamental
\item Complete procedure consists of four essential steps
\item Renormalized correlators correspond to reversible computations (truth)
\item RG fixed points correspond to scale-invariant computational processes
\end{enumerate}

The renormalisation procedure bridges formal mathematical structure and semantic computational truth. The next section develops the formal logic framework underlying this structure (Section~\ref{sec:formal-systems}).

\paragraph{Log-domain semiring.} The lt-core now exposes a log-exp semiring whose addition is the log-sum-exp operator and whose multiplication is additive. This provides a faithful coding of the logarithmic RG algebra used above: counterterms and coarse-grained weights are combined exactly as the renormalisation equations dictate, and the code generator can emit log-domain libraries for Coq, Agda, or Isabelle whenever a domain needs those identities.

\paragraph{Ledger note.} The four-step renormalisation routine is recorded as a reusable logic pattern: in later sections we will call upon the same steps to argue consistency (Section~\ref{sec:consistency}) and to characterise LLM training flows (Section~\ref{sec:llm_rg}). Only the domain-specific interpretation of the weights changes; the logical skeleton remains domain-neutral.
