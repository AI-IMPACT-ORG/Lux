\section{Logic Transformer Framework}
\label{sec:formal-systems}

Having established the renormalization framework in Section~\ref{sec:renormalization}, we now develop the formal logic structure that underlies it. We consider \textbf{conservative extensions of theories} $T\subseteq\mathrm{Sent}(\Sigma)$ inside a fixed logic $\mathcal{L}=(\Sigma,\vdash)$; when proof rules change, we speak of a \textbf{logic morphism}. The logic transformer emerges as the central logical primitive that unifies all computational paradigms through a conservative extension of logic with hierarchical deformation of truth systems.

\subsection{Design Crosswalk: Paper $\leftrightarrow$ Implementation}

To anchor our theoretical development in concrete implementation, we provide the following correspondence between our paper's concepts and the explicit logic implementation:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Paper Concept} & \textbf{Implementation (M123\_d)} \\
\hline
$\Sigma_6$ / $\mathsf{G}_6$ & \texttt{Sigma6} (arity (3,3)) in \texttt{m3d.types.rkt} \\
Typed graph (model) & \texttt{TGraph} / \texttt{Node} / \texttt{Edge} in \texttt{m3d.graph.rkt} \\
Theory / formula & PGC constructors \texttt{Top/MatchX/Exists/And/Or} in \texttt{m2d.pgc-core.rkt} \\
Guards / boundaries & \texttt{Submono}, \texttt{View}, \texttt{GuardEnv} in \texttt{m3d.graph.rkt} \\
Truth / satisfaction & \texttt{pgc-eval}, \texttt{satisfies\^{}} over \texttt{Semiring} in \texttt{m2d.semiring.rkt} \\
Observers & \texttt{q-local-fast}, \texttt{q-global-fast} as RG observables \\
Certificates & \texttt{Cert} and \texttt{cert->submono} in \texttt{m2d.cert.rkt} \\
Logic transformer & \texttt{M1Logic}, \texttt{TransformerLogic} in \texttt{m1d.logic.rkt} \\
\hline
\end{tabular}
\caption{Correspondence between paper concepts and implementation}
\label{tab:design-crosswalk}
\end{table}

\subsection{Conservative Extension of Logic}

\begin{definition}[Conservative Extension of Logic]
\label{def:conservative-extension}
A conservative extension of a logic $\mathcal{L}$ is a logic $\mathcal{L}'$ such that:
\begin{enumerate}
\item $\mathcal{L} \subseteq \mathcal{L}'$ (syntactic extension)
\item For any formula $\phi$ in the language of $\mathcal{L}$: $\mathcal{L} \vdash \phi$ if and only if $\mathcal{L}' \vdash \phi$ (semantic conservation)
\item $\mathcal{L}'$ introduces new vocabulary and axioms that do not affect the truth of statements in the original language
\end{enumerate}
The conservativity condition can be expressed as:
\[
\forall \phi \in \text{Sent}(\Sigma): \quad \mathcal{L} \vdash \phi \Leftrightarrow \mathcal{L}' \vdash \phi
\]
where $\text{Sent}(\Sigma)$ denotes the sentences in the original signature $\Sigma$.
\end{definition}

\begin{example}[Concrete Conservative Extension]
\label{ex:conservative-extension}
Consider extending our base logic $\mathcal{L}_0$ (PGC over \texttt{TGraph} with Boolean semiring) by adding \texttt{cast} edges (cf. \texttt{m3d.types.rkt} natural casts). The extension $\mathcal{L}_1$ adds the syntax:
\[
\text{cast}: \mathcal{T}_1 \to \mathcal{T}_2
\]
with typing rules ensuring type safety. The extension is conservative because:
\begin{itemize}
\item Boolean satisfaction on old formulas is preserved: $\mathcal{L}_0 \models \phi \Leftrightarrow \mathcal{L}_1 \models \phi$
\item New \texttt{cast} operations don't affect the truth of existing statements
\item The extension maintains the same proof system for the original language
\end{itemize}
\end{example}

\subsection{Hierarchical Deformation of Truth Systems}

\begin{definition}[Hierarchical Deformation]
\label{def:hierarchical-deformation}
A hierarchical deformation of a truth system is a family of truth predicates $\text{True}_\alpha$ indexed by ordinals $\alpha$ such that:
\begin{align}
\text{True}_0(\phi) &\Leftrightarrow \text{True}(\phi) \quad \text{(original truth)} \\
\text{True}_{\alpha+1}(\phi) &\Leftrightarrow \text{True}_\alpha(\phi) \land \text{Consistent}_\alpha(\phi) \\
\text{True}_\lambda(\phi) &\Leftrightarrow \forall \alpha < \lambda: \text{True}_\alpha(\phi) \quad \text{(limit case)}
\end{align}
where $\text{Consistent}_\alpha(\phi)$ ensures consistency at level $\alpha$.
\end{definition}

\subsection{The Logic Transformer}

\begin{definition}[Logic Transformer]
\label{def:logic-transformer}
The logic transformer is a polymorphic generalization of scaling operators in physics. It is an arity $(2,2)$ operator $\mathcal{T}$ that acts on pairs of formulas and returns pairs of formulas:
\[
\mathcal{T}: \mathcal{L} \times \mathcal{L} \to \mathcal{L} \times \mathcal{L}
\]
where the transformation preserves the logical structure while introducing scaling behavior. The operator satisfies:
\begin{align}
\mathcal{T}(\phi_1, \phi_2) &= (\mathcal{T}_1(\phi_1, \phi_2), \mathcal{T}_2(\phi_1, \phi_2)) \\
\mathcal{T}(\text{True}, \text{True}) &= (\text{True}, \text{True}) \quad \text{(preserves truth)}
\end{align}
\end{definition}

\subsection{Kernel, Co-kernel, and Spectrum}

\begin{definition}[Kernel and Co-kernel]
\label{def:kernel-cokernel}
The kernel $\ker(\mathcal{T}) = \{(\phi_1, \phi_2) : \mathcal{T}(\phi_1, \phi_2) = (\text{True}, \text{True})\}$ and co-kernel $\text{coker}(\mathcal{T}) = \{(\psi_1, \psi_2) : \exists (\phi_1, \phi_2), \mathcal{T}(\phi_1, \phi_2) = (\psi_1, \psi_2)\}$ correspond to reversible and irreversible computations respectively.
\end{definition}

\begin{definition}[Logic Transformer Spectrum]
\label{def:logic-spectrum}
The spectrum consists of eigenvalues $\lambda$ where $\mathcal{T}(\phi_1, \phi_2) = \lambda (\phi_1, \phi_2)$, with a spectral gap between kernel (reversible) and co-kernel (irreversible) computations.
\end{definition}

\subsection{Connections to Programming Languages and Logic}

\begin{remark}[Partial Self-Evaluation Operator]
\label{rem:partial-self-evaluation}
The logic transformer is a "partial self-evaluation" operator in programming language theory, implementing compilation as logical transformation.
\end{remark}

\begin{remark}[Diagonal Lemma Connection]
\label{rem:diagonal-lemma}
The logic transformer implements self-referential construction for Gödel's incompleteness theorems, providing the mechanism for undecidable statements.
\end{remark}

\subsection{Correlator Interpretation}

\begin{definition}[Logic Transformer as Correlator]
\label{def:logic-correlator}
The logic transformer acts as a correlator for logical propagation: $(\psi_1, \psi_2) = \mathcal{T}(\phi_1, \phi_2)$ where $(\psi_1, \psi_2)$ represents the logical state after transformation.
\end{definition}

\subsection{Holographic Renormalization}

\begin{definition}[Holographic Renormalization]
\label{def:holographic-renorm}
The logic transformer gives rise to two boundaries with direction, leading to holographic renormalization (detailed in Section~\ref{sec:boundary-maps}).
\end{definition}

\subsection{Summary and Outlook}

This section established the logic transformer framework:

\begin{enumerate}
\item Conservative extension of logic provides syntactic foundation
\item Hierarchical deformation of truth systems enables logical structure
\item Logic transformer is the central arity (2,2) operator
\item Kernel/co-kernel correspond to reversible/irreversible computation
\item Spectral gap measures computational complexity
\end{enumerate}

The logic transformer provides the mathematical foundation unifying computation, logic, and physics. The next section establishes truth as a fixed point under RG flow (Section~\ref{sec:truth-fixed-point}).

Spectral notions refer to the \textbf{transfer operator} on correlators (defined in §11), not to the proof calculus itself.