\section{An Invitation to Computation: Three Views Unified}
\label{sec:computation-paradigms}

This section serves as our gateway from classical computational literature to a novel generating functional approach. We demonstrate how the three foundational paradigms of computation—Turing machines, Church's lambda calculus, and Feynman path integrals—can be elegantly unified as different parameterizations of a single generating function. This unification reveals deep structural connections that are obscured in traditional presentations.

\subsection{The Computational Cycle}

At its core, computation can be understood as the composition of four fundamental operations: \textbf{encoding} $\to$ \textbf{function application} $\to$ \textbf{normalization} $\to$ \textbf{decoding}. This four-step pipeline appears consistently across all computational paradigms, with normalization playing a crucial role in ensuring well-defined results. The computational cycle can be expressed as:
\[
\text{Encode}(x) \circ \text{Apply}(f) \circ \text{Normalize}(N) \circ \text{Decode}(y) = y
\]
where $N$ is a normalization operator satisfying $N^2 = N$ (idempotency). In classical treatments, normalization can occur at any stage (commuting as an operator), which forms the foundation of compiler theory in programming languages.

Our central innovation is the introduction of a logical primitive—a 6-ary connective—whose denotation is a generating function that naturally interpolates between the three classical computational models:

\begin{definition}[6-ary Connective $\mathsf{G}_6$]
\label{def:sixary-connective}
The 6-ary connective $\mathsf{G}_6$ is a functor with signature:
\[
\mathsf{G}_6 : \mathbf{Types}^{\mathrm{op}} \times \mathbf{Types} \times \mathsf{Grad} \times \mathsf{Scale} \to \mathsf{Obs}
\]
where:
\begin{itemize}
\item $\mathbf{Types}$ is the category of computational types (objects: register types, morphisms: type coercions)
\item $\mathsf{Grad} = \mathbb{R}^3$ is the grading space (poset with componentwise ordering)
\item $\mathsf{Scale} = \mathbb{R}_+$ is the scale space (poset with standard ordering)
\item $\mathsf{Obs}$ is the observable space (symmetric monoidal category with tensor product $\otimes$)
\end{itemize}
The connective acts on two register terms $\phi,\bar{\phi}\in\mathbf{Types}$ with grading $\vec{q}\in\mathsf{Grad}$ at scale $\Lambda\in\mathsf{Scale}$, producing an observable in $\mathsf{Obs}$:
\[
\mathsf{G}_6(\phi,\bar{\phi};\,\vec{q};\Lambda) \in \mathsf{Obs}
\]
\end{definition}
The denotation of this connective is given by:
\[
\llbracket \mathsf{G}_6(\phi,\bar{\phi};\vec{q};\Lambda)\rrbracket = \mathcal{G}\!\big(\llbracket\phi\rrbracket,\llbracket\bar{\phi}\rrbracket;\vec{q},\Lambda\big)
\]
where the generating function takes the form:
\begin{equation}
\mathcal{G}(z,\bar{z};\vec{q},\Lambda) = \sum_{n,m\ge0}\frac{z^n\bar{z}^{\,m}}{n!\,m!}\,\mathcal{Z}_{n,m}(\vec{q})\,\Lambda^{-(n+m)}.
\label{eq:generating-function}
\end{equation}
This is an \textbf{exponential generating function (EGF)} because the coefficients $\mathcal{Z}_{n,m}(\vec{q})$ count \textbf{labeled structures} (computational paths with distinguishable steps). The factorial weights $n!\,m!$ arise from the derivative structure: $\mathcal{Z}_{n,m}(\vec{q}) = \frac{\partial^{n+m}\mathcal{G}}{\partial z^n \partial \bar{z}^m}\big|_{z=\bar{z}=0}$.

\textbf{Units}: If $\Lambda$ has mass dimension $[L]^{-1}$, then $\mathcal{Z}_{n,m}(\vec{q})$ must have mass dimension $[L]^{n+m}$ to make $\mathcal{G}$ dimensionless. Here $n,m$ are the \textbf{bi-degree counters} (writes/reads / redex counts / insertions), and $\mathcal{Z}_{n,m}(\vec{q})$ are correlator coefficients (matrix elements) invariant under normalization.

\textbf{Toy}: with $\vec{q}=(1,0,0)$ and one active rewrite, $\mathcal{Z}_{1,0}=1$, others $0$; then $\mathcal{G}=z$. We reuse this toy in §3.

\paragraph{Parameter Dependence and Input/Output Structure}
The generating function $\mathcal{G}$ has explicit parameter dependence that we make transparent:
\begin{align}
\text{Input variables:} \quad & z, \bar{z} \in \mathbb{C} \quad \text{(register encodings)} \\
\text{Parameter variables:} \quad & \vec{q} \in \mathbb{R}^3 \quad \text{(grading/coupling parameters)} \\
\text{Scale variable:} \quad & \Lambda \in \mathbb{R}_+ \quad \text{(RG scale)} \\
\text{Output:} \quad & \mathcal{G}(z,\bar{z};\vec{q},\Lambda) \in \mathbb{C} \quad \text{(observable value)}
\end{align}

\paragraph{Fixed Operator Insertion Correlator}
To make the implicit vector structure explicit, we introduce a correlator with fixed operator insertion:
\begin{definition}[Fixed Operator Correlator]
\label{def:fixed-operator-correlator}
For a fixed operator $\hat{O}$ and computational state $|\psi\rangle$, define:
\[
\mathcal{C}_{\hat{O}}(z,\bar{z};\vec{q},\Lambda) = \langle\psi|\hat{O}|\psi\rangle \cdot \mathcal{G}(z,\bar{z};\vec{q},\Lambda)
\]
This correlator encodes the expectation value of $\hat{O}$ in the computational state, weighted by the generating function structure.
\end{definition}

The computational weights $\mathcal{Z}_{n,m}(\vec{q})=\langle n,m|\hat{W}(\vec{q})|0\rangle$ appearing in equation~\eqref{eq:generating-function} are matrix elements of an operator $\hat{W}(\vec{q})$ in a graded Fock basis $\{|n,m\rangle\}$ of a unitary $\text{Vir}\oplus\overline{\text{Vir}}$ module. This mathematical foundation, which provides the rigorous underpinning for our computational framework, will be developed in detail in Section~\ref{sec:formal-systems}.

\paragraph{Virasoro representation (for hep-th readers)}
For our HEP-TH audience, this mathematical structure should feel immediately familiar. We work in a unitary highest-weight $\mathrm{Vir}\oplus\overline{\mathrm{Vir}}$ representation with $L_n^\dagger=L_{-n}$ and central charge $c$. The standard commutation relations are:
\[
[L_m,L_n]=(m-n)L_{m+n}+\frac{c}{12}(m^3-m)\delta_{m,-n},\qquad [L_m,\bar{L}_n]=0,
\]
with analogous relations for $\bar{L}_n$. The basis $\{|n,m\rangle\}_{n,m\ge0}$ diagonalizes $(L_0,\bar{L}_0)$ on a bosonic subspace, providing a structure analogous to the Fock space familiar from quantum field theory.

The operation stage of our computational cycle is implemented through a transfer operator:
\[
\hat{T}_{\text{comp}}(\Lambda)=a_0(\Lambda)(L_0+\bar{L}_0)+\sum_{n\ge1}a_n(\Lambda)\,(L_{-n}+L_n+\bar{L}_{-n}+\bar{L}_n)
\]
with $a_{-n}=a_n\in\mathbb{R}$ ensuring boundedness and rapid decay in $n$, ensuring convergence of the series. A computational run terminates when the vacuum overlap exceeds a predetermined threshold: $\langle\psi(t)|0\rangle\langle 0|\psi(t)\rangle\ge\tau$.

\subsection{Three Computational Paradigms}

The grading parameters $\vec{q}$ in equation~\eqref{eq:generating-function} select specific corners of our computational landscape, corresponding to the three classical paradigms:
\begin{itemize}
\item \textbf{Turing Machines} $\vec{q} = (1,0,0)$: Discrete state transitions with finite control
\item \textbf{Lambda Calculus} $\vec{q} = (0,1,0)$: Functional composition and $\beta$-reduction  
\item \textbf{Path Integrals} $\vec{q} = (0,0,1)$: Quantum interference between computational paths
\end{itemize}

The paradigm selection is governed by the weight function:
\[
w(p;\vec{q}) = q_1^{n_1} q_2^{n_2} q_3^{n_3}
\]
where $n_i$ counts the number of operations of type $i$ in path $p$. Generic values of $\vec{q}$ interpolate smoothly between these paradigms, revealing the continuous nature of the computational landscape. The detailed mathematical embeddings and their equivalence (Church-Turing thesis) will be rigorously established in Section~\ref{sec:rg-flow}.

\subsection{Example: The Church-Turing Equivalence}

To illustrate the power of our unified framework, let us trace the computation $5-3=2$ across all three paradigms, demonstrating how the same logical operation manifests through different mathematical structures:

\begin{example}[One-step $\beta$-reduction via $\mathsf{G}_6$]
\label{ex:concrete-reduction}
Let $q_2=1$ and $q_1=q_3=0$. With registers $\phi=(\lambda x.M)$ and $\bar{\phi}=N$,
\[
\mathsf{G}_6(\phi,\bar{\phi};\vec{q};\Lambda) \leadsto M[x:=N] \quad \text{(single $\Lambda$-step)}.
\]
This demonstrates how the 6-ary connective recovers lambda calculus $\beta$-reduction through appropriate parameter choices. The grading parameter $q_2$ controls $\beta$-like rewrites measured in $\mathcal{Z}_{n,m}$.
\end{example}

\begin{example}[DFA transition via $\mathsf{G}_6$]
\label{ex:dfa-reduction}
Consider our running toy example from Figure~\ref{fig:toy-example}. A single step of a deterministic finite automaton (DFA) can be encoded as:
\begin{align}
\text{Input state } A &: \text{encoded as } z^5 \bar{z}^3 \\
\text{Transition via } \Sigma_6 &: \text{applies } \mathcal{Z}_{5,3}(\vec{q}) \\
\text{Output state } B &: \text{decoded as } z^2 \bar{z}^0
\end{align}
The $\mathsf{G}_6$ connective with $\vec{q} = (1,0,0)$ (Turing machine paradigm) implements this as:
\[
\mathsf{G}_6(z^5\bar{z}^3, \vec{q}=(1,0,0), \Lambda) \mapsto z^2\bar{z}^0
\]
This demonstrates how the 6-ary connective recovers standard machine models through appropriate parameter choices.
\end{example}

\begin{lemma}[Well-Typed Steps]
\label{lem:well-typed-steps}
Any $\Sigma_6$-edge graph with guards $X,Y$ has a well-typed step if and only if the computational weights $\mathcal{Z}_{n,m}(\vec{q})$ satisfy the typing constraints for the given paradigm $\vec{q}$.
\end{lemma}

All three paradigms represent the identical computation $5-3=2$ through different mathematical structures:

- **Turing Machines** $\vec{q} = (1,0,0)$: State transitions via $\mathcal{Z}_{5,3}(1,0,0)$
- **Lambda Calculus** $\vec{q} = (0,1,0)$: $\beta$-reduction via $\mathcal{Z}_{5,3}(0,1,0)$  
- **Path Integrals** $\vec{q} = (0,0,1)$: Path summation via $\mathcal{Z}_{5,3}(0,0,1)$

The factorial prefactors $\frac{1}{n!m!}$ in equation~\eqref{eq:generating-function} ensure proper counting of state configurations across paradigms.

\subsection{Summary and Outlook}

This section established our unified computational framework:

\begin{enumerate}
\item 6-ary connective $\mathsf{G}_6$ provides the logical primitive whose denotation is the generating function
\item Generating function $\mathcal{G}(z, \bar{z}; \vec{q}, \Lambda)$ unifies the three computational paradigms
\item Four-step pipeline (encode $\to$ operate $\to$ normalize $\to$ decode) appears consistently across paradigms
\item Virasoro algebra provides the mathematical foundation for computational dynamics
\end{enumerate}

The three paradigms are different manifestations of the same structure, all governed by the same generating function and RG equations (developed in Section~\ref{sec:rg-flow}). This unified perspective reveals deep structural connections hidden in traditional presentations.

The parameter map we use matches classical choices in Turing/Church/circuit models and CFT (central charge, weights)—what is \textbf{new here} is elevating \textbf{normalization} to a first-class, cross-view unifier; §3 turns these into \textbf{renormalization conditions}.