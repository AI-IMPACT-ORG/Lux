\section{Mathematical Background and Notation}
\label{app:mathematical-background}

This appendix provides comprehensive mathematical background and notation used throughout this paper.

\subsection{Basic Mathematical Notation}
\begin{itemize}
\item $\mathbb{N}$: Natural numbers $\{0, 1, 2, \ldots\}$
\item $\mathbb{Z}$: Integers $\{\ldots, -2, -1, 0, 1, 2, \ldots\}$
\item $\mathbb{R}$: Real numbers
\item $\mathbb{C}$: Complex numbers
\item $\mathbb{R}^+$: Positive real numbers
\item $\mathbb{C}^3$: Three-dimensional complex space
\item $[0,1]$: Closed interval from 0 to 1
\item $(0,1]$: Half-open interval from 0 to 1 (excluding 0)
\end{itemize}

\subsection{Set Theory and Logic}
\begin{itemize}
\item $\in$: Element of
\item $\subseteq$: Subset of
\item $\cup$: Union
\item $\cap$: Intersection
\item $\emptyset$: Empty set
\item $\{x : P(x)\}$: Set comprehension
\item $\forall$: Universal quantifier (for all)
\item $\exists$: Existential quantifier (there exists)
\item $\Rightarrow$: Implication
\item $\Leftrightarrow$: If and only if
\item $\neg$: Negation
\item $\wedge$: Conjunction (and)
\item $\vee$: Disjunction (or)
\end{itemize}

\subsection{Function and Operator Notation}
\begin{itemize}
\item $f: A \to B$: Function from set $A$ to set $B$
\item $f(x)$: Function application
\item $\lambda x.M$: Lambda abstraction
\item $M[x := N]$: Substitution of $N$ for $x$ in $M$
\item $\mathsf{INC}(R_i)$: Increment register $R_i$
\item $\mathsf{DEC}(R_i)$: Decrement register $R_i$
\item $\mathsf{IFZERO}(R_i, j)$: If register $R_i$ is zero, jump to instruction $j$
\item $\mathsf{Halts}_\tau(t)$: Halting predicate with threshold $\tau$
\end{itemize}

\subsection{Computational Paradigms}
\begin{itemize}
\item $\mathsf{TM}$: Turing machine
\item $\mathsf{Minsky}$: Minsky machine
\item $\lambda$: Lambda calculus
\item $\mathsf{F}$: Feynman (quantum) computation
\item $\mathsf{AGT}$: Alday-Gaiotto-Tachikawa correspondence
\end{itemize}

\subsection{Generating Function Notation}
\begin{itemize}
\item $G(z,\bar{z};q_1,q_2,q_3,\Lambda)$: Generating function
\item $z, \bar{z}$: Complex variables (computational registers)
\item $q_1, q_2, q_3$: Grading parameters
\item $\Lambda$: Scale parameter
\item $\mathcal{Z}_{n,m}(q_1,q_2,q_3)$: Computational weights
\item $n, m$: Virasoro levels
\item $\ell$: Virasoro mode indices
\end{itemize}

\subsection{renormalisation Group Notation}
\begin{itemize}
\item $\beta_i(q_1,q_2,q_3)$: Beta functions ($i = 1,2,3$)
\item $\gamma(q_1,q_2,q_3)$: Gamma function
\item $\epsilon_T, \epsilon_C, \epsilon_F$: Regulators (Turing, Church, Feynman)
\item $\delta q_i$: Counterterms
\item $q_i^{(0)}$: Bare parameters
\item $G_{\text{reg}}$: Regularized generating function
\item $G_{\text{ren}}$: Renormalized generating function
\end{itemize}

\subsection{Formal Logic Notation}
\begin{itemize}
\item $\Sigma$: Signature
\item $t$: Terms
\item $\models$: Satisfaction relation
\item $\equiv_L, \equiv_B, \equiv_R$: Boundary equalities
\item $\equiv_\star, \equiv_B, \equiv_{\text{meta}}$: Simplified equality hierarchy
\item $\mathsf{Gen4}$: Core primitive operator
\item $\text{ad}_i$: Braided dual operators
\item $F_{ij}$: Braiding coefficients
\end{itemize}

\subsection{Category Theory Background}

This section provides the minimal category theory background \cite{maclane1971,lambek1968,karoubi1970,eilenberg1965,street1972} needed for our framework.

\subsubsection{Basic Definitions}

\begin{definition}[Category]
A category $\mathcal{C}$ consists of:
\begin{itemize}
\item A collection of objects $\text{Ob}(\mathcal{C})$
\item For each pair of objects $A, B \in \text{Ob}(\mathcal{C})$, a set of morphisms $\text{Hom}(A,B)$
\item For each object $A$, an identity morphism $\text{id}_A \in \text{Hom}(A,A)$
\item For each triple of objects $A, B, C$, a composition operation $\circ: \text{Hom}(B,C) \times \text{Hom}(A,B) \to \text{Hom}(A,C)$
\end{itemize}
satisfying associativity and identity laws.
\end{definition}

\begin{definition}[Monoidal Category]
A monoidal category $(\mathcal{C}, \otimes, I)$ is a category $\mathcal{C}$ equipped with:
\begin{itemize}
\item A tensor product functor $\otimes: \mathcal{C} \times \mathcal{C} \to \mathcal{C}$
\item A unit object $I \in \text{Ob}(\mathcal{C})$
\item Natural isomorphisms for associativity and unit
\end{itemize}
\end{definition}

\subsubsection{Examples}

\begin{example}[Set Category]
The category $\text{Set}$ has:
\begin{itemize}
\item Objects: Sets
\item Morphisms: Functions between sets
\item Tensor product: Cartesian product $\times$
\item Unit: Singleton set $\{*\}$
\end{itemize}
\end{example}

\begin{example}[Vector Space Category]
The category $\text{Vect}_k$ has:
\begin{itemize}
\item Objects: Vector spaces over field $k$
\item Morphisms: Linear maps
\item Tensor product: Tensor product of vector spaces
\item Unit: Field $k$ as a one-dimensional vector space
\end{itemize}
\end{example}

\subsection{Implicit Functional Arguments Convention}
\begin{itemize}
\item $z, \bar{z}$: Scale scalars that serve as implicit functional arguments
\item Convention: When $\mathsf{Gen4}(a_1, a_2, a_3, a_4)$ appears without explicit $z, \bar{z}$ arguments, these are understood to be implicit functional arguments
\item Full notation: $\mathsf{Gen4}(a_1, a_2, a_3, a_4; z, \bar{z})$ where $z, \bar{z}$ encode presentation gauges
\item Overall scale: $z \otimes_B \bar{z}$ represents the overall scale factor
\item Eliminability: The scale scalars $z, \bar{z}$ are eliminable (conservative extension) and can be factored out in all observational equalities
\end{itemize}

This notation guide provides the foundation for understanding the mathematical structures used throughout the paper. All symbols maintain their logical structure while acquiring domain-specific semantic content through the systematic translation maps documented in Table~\ref{tab:universal-domain-translation}.
